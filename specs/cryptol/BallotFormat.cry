// A number of _contests_ where a unique _candidate_ is selected for
// each contest.

// @author Giuliano Losa <giuliano@galois.com>
// @author Joe Kiniry <kiniry@freeandfair.us>

// We have a number `nct` of contests `(0,1,...,nct-1)` with `ncd`
// candidates `(0,1,...,ncd-1)` per contest.  Given a contest, a
// selection for candidate `i` where `0 <= i < ncd` is represented as
// `i:[width (ncd-1)]`.  A ballot is a vector of size `nct` where each
// entry is a bitvector of length `width (ncd-1)`.  There must be at
// least 2 candidates and, of course, everything is finite.

type ballot nct ncd = [nct][width (ncd-1)]

type constraint ballot_constraint nct ncd =
  (fin nct, fin ncd, nct >= 1, ncd >= 2)

// a ballot is valid when each selection is a number between 0 and
// (ncd-1) included
is_valid : {nct, ncd} ballot_constraint nct ncd => ballot nct ncd -> Bit
is_valid b = all (\x -> x <= `(ncd-1)) [b@i | i <- [0..(nct-1)]]

// Given a valid ballot, `selection b ct == cd` if and only if candidate
// `cd` is selected in contest `ct`.
selection : {nct, ncd} ballot_constraint nct ncd =>
  ballot nct ncd -> [width (nct-1)] -> [width (ncd-1)]
selection b ct = (b@ct)

// @todo giuliano Do we want to represent a ballot as an array of
// booleans instead?  That is what `ballot_2` specifies:

type ballot_2 nct ncd = [nct][ncd] // one bit per candidate

// A ballot is valid if and only if there is exactly one choice per
// contest.
is_valid_2 : {nct, ncd} ballot_constraint nct ncd => ballot nct ncd -> Bit
is_valid_2 b = all valid b
  where valid x = x != zero /\ x && (x-1) == 0

// Given a valid ballot, `selection_2 b ct == cd` if and only if
// candidate `cd` is selected in contest `ct`.
selection_2 : {nct, ncd} ballot_constraint nct ncd =>
  ballot nct ncd -> [width (nct-1)] -> [width (ncd-1)]
selection_2 b ct = (last xs).1
  where xs = [(False, 0)] # [
    if stop then (stop,cd) else (if (b@ct@i) then (True, i) else (False,0))
    | i <- [0..ncd-1]
    | (stop,cd) <- xs ]
