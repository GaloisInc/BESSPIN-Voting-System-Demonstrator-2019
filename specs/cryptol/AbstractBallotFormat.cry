module AbstractBallotFormat where

import Base64 (encodeBase64, decodeBase64, Base64, Base64Length)
import Padding
import BaseConvert
import AESCBC

// Time encoding
type Time = {
  year   : [16],
  month  : [8],
  day    : [8],
  hour   : [8],
  minute : [8]
}

timeToDigits : Time -> [16][8]
timeToDigits time =
  yearDigits # sep # monthDigits # sep # dayDigits # sep # hourDigits # sep # minuteDigits
    where
  sep          = "+"
  yearDigits   = drop`{back=4} (toBase`{digits=5} decimal time.year)
  monthDigits  = drop`{back=2} (toBase`{digits=3} decimal time.month)
  dayDigits    = drop`{back=2} (toBase`{digits=3} decimal time.day)
  hourDigits   = drop`{back=2} (toBase`{digits=3} decimal time.hour)
  minuteDigits = drop`{back=2} (toBase`{digits=3} decimal time.minute)

testTime = {
  year   = 2019,
  month  = 1,
  day    = 1,
  hour   = 1,
  minute = 1
}

// Ballot encoding
type Ballot contests positions
  = { time     : Time,
      unixTime : [6][8],
      contests : [contests][positions] }

encodeBallot :
  {contests, positions, encodedLength}
  (fin contests, fin positions,
   encodedLength == 16 + 16 * ((6 + (contests * positions) /^ 8) /^ 16)) =>
  [32][8] ->
  [32][8] ->
  [16][8] ->
  Ballot contests positions ->
  [1 + 16 + Base64Length encodedLength][8]
encodeBallot authKey ballotKey iv ballot =
  timeDigits # ":" # encodeBase64 (encryptedBallot # auth)
  where
    timeDigits      = timeToDigits ballot.time
    timeBytes       = ballot.unixTime
    contestsBytes   = groupBy`{8} (padWith`{mod=8} zero (join ballot.contests))
    ballotBytes     = timeBytes # contestsBytes
    encryptedBallot = encrypt ballotKey iv (padWith`{mod=16} zero ballotBytes)
    auth            = cbcMAC authKey zero (padWith`{mod=16} zero (timeDigits # encryptedBallot))
/*
decodeBallot :
  {contests, positions, encodedLength}
  (fin contests, fin positions,
   encodedLength == 16 + 16 * ((timeDigits + (contests * positions) /^ 8) /^ 16)) =>
  [32][8] ->
  [32][8] ->
  [16][8] ->
  [1 + timeDigits + Base64Length encodedLength][8] ->
  Ballot contests positions
decodeBallot authKey ballotKey iv encoded =
  if padding != zero
  then error "Invalid (non-zero) ballot padding"
  | auth != cbcMAC authKey zero (padWith`{mod=16} zero (groupBy`{8} time # encryptedBallot))
  then error "Invalid CBC-MAC authentication: this ballot has been tampered with!"
  | outerTimePadding != zero
  then error "Invalid plain text timestamp: out of range"
  | timePadding != zero
  then error "Invalid encrypted timestamp: out of range"
  | outerTime != time
  then error "Outer-inner timestamp mismatch: should be impossible with valid auth"
  else
  { time = time, contests = split contests }
  where
    outerTimeDigits : [timeDigits][8]
    encodedBallot : Base64 encodedLength
    outerTimeDigits # _ # encodedBallot = encoded

    auth : [16][8]
    encryptedBallot :
      [16 * ((timeDigits + (contests * positions) /^ 8) /^ 16)][8]
    encryptedBallot # auth =
      decodeBase64`{encodedLength} encodedBallot

    timeDigitsBits : [timeDigits * 8]
    contests : [contests * positions]

    timeDigitsBits # contests # padding =
      join (decrypt ballotKey iv encryptedBallot)

    time, outerTime               : [timeBytes * 8]
    timePadding, outerTimePadding : [width (10 ^^ timeDigits) - timeBytes * 8]

    timePadding      # time       = fromBase decimal (groupBy`{8} timeDigitsBits)
    outerTimePadding # outerTime  = fromBase decimal outerTimeDigits

// Proofs that ballot encoding is correct

ballot_roundtrip :
  {contests, positions} (fin contests, fin positions) =>
  [32][8] -> [32][8] -> [16][8] -> Ballot contests positions -> Bool
property ballot_roundtrip authKey ballotKey iv ballot =
  decodeBallot authKey ballotKey iv (encodeBallot authKey ballotKey iv ballot) == ballot
  */