module AbstractBallotFormat where

import Base64 (encodeBase64, decodeBase64, Base64)
import Padding
import BaseConvert
import AESCBC

// Ballot encoding

parameter
  type timeBytes  : #
  type seqBytes   : #
  type timeDigits : #
  type seqDigits  : #
  type constraint (fin timeBytes,  fin seqBytes,
                   fin timeDigits, fin seqDigits,
                   timeBytes  >= 1, seqBytes  >= 1,
                   timeDigits >= 1, seqDigits >= 1,
                   width (10 ^^ timeDigits) >= 8 * timeBytes,
                   width (10 ^^ seqDigits)  >= 8 * seqBytes,
                   10 ^^ timeDigits >= 2 ^^ (timeBytes * 8),
                   10 ^^ seqDigits  >= 2 ^^ (seqBytes * 8))

type Ballot contests positions
  = { time     : [timeBytes * 8],
      number   : [seqBytes  * 8],
      contests : [contests][positions] }

encodeBallot :
  {contests, positions, encodedLength}
  (fin contests, fin positions, fin timeDigits, fin seqDigits,
   encodedLength == 16 + timeDigits + 16 * ((timeDigits + seqDigits + (contests * positions) /^ 8) /^ 16)) =>
  [32][8] ->
  [32][8] ->
  [16][8] ->
  Ballot contests positions ->
  Base64 encodedLength
encodeBallot authKey ballotKey iv ballot =
  encodeBase64 (encryptedBallot # timeDigits # auth)
  where
    seqDigits       = toBase`{digits=seqDigits}  decimal ballot.number
    timeDigits      = toBase`{digits=timeDigits} decimal ballot.time
    contestsBytes   = groupBy`{8} (padWith`{mod=8} zero (join ballot.contests))
    ballotBytes     = seqDigits # timeDigits # contestsBytes
    encryptedBallot = encrypt ballotKey iv ballotBytes
    auth            = cbcMAC authKey zero (encryptedBallot # timeDigits)

decodeBallot :
  {contests, positions, encodedLength}
  (fin contests, fin positions,
   encodedLength == 16 + timeDigits + 16 * ((timeDigits + seqDigits + (contests * positions) /^ 8) /^ 16)) =>
  [32][8] ->
  [32][8] ->
  [16][8] ->
  Base64 encodedLength ->
  Ballot contests positions
decodeBallot authKey ballotKey iv encodedBallot =
  if padding != zero
  then error "Invalid (non-zero) ballot padding"
  | cbcMAC authKey zero (encryptedBallot # outerTimeDigits) != auth
  then error "Invalid CBC-MAC authentication: this ballot has been tampered with!"
  | outerTimePadding != zero
  then error "Invalid outer timestamp: out of range"
  | numPadding != zero
  then error "Invalid sequence number: out of range"
  | timePadding != zero
  then error "Invalid timestamp: out of range"
  | outerTime != time
  then error "Outer-inner timestamp mismatch: should be impossible with valid auth"
  else
  { number = number, time = time, contests = split (contests) }
  where
    encryptedBallot : [16 * ((timeDigits + seqDigits + (contests * positions) /^ 8) /^ 16)][8]
    outerTimeDigits : [timeDigits][8]
    auth            : [16][8]

    encryptedBallot # outerTimeDigits # auth =
      decodeBase64`{encodedLength} encodedBallot

    numberBits : [seqDigits * 8]
    timeBits   : [timeDigits * 8]
    contests : [contests * positions]

    numberBits # timeBits # contests # padding =
      join (decrypt`{timeDigits + seqDigits + (contests * positions) /^ 8}
                    ballotKey iv encryptedBallot)

    number          : [seqBytes  * 8]
    time, outerTime : [timeBytes * 8]
    numPadding                    : [width (10 ^^ seqDigits) - seqBytes * 8]
    timePadding, outerTimePadding : [width (10 ^^ timeDigits) - timeBytes * 8]

    numPadding       # number    = fromBase decimal (groupBy`{8} numberBits)
    timePadding      # time      = fromBase decimal (groupBy`{8} timeBits)
    outerTimePadding # outerTime = fromBase decimal outerTimeDigits

// Proofs that ballot encoding is correct

ballot_roundtrip :
  {contests, positions} (fin contests, fin positions) =>
  [32][8] -> [32][8] -> [16][8] -> Ballot contests positions -> Bool
property ballot_roundtrip authKey ballotKey iv ballot =
  decodeBallot authKey ballotKey iv (encodeBallot authKey ballotKey iv ballot) == ballot