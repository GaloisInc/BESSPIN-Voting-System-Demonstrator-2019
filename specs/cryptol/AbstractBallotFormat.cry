module AbstractBallotFormat where

import Base64 (encodeBase64, decodeBase64, Base64, Base64Length)
import Padding
import BaseConvert
import AESCBC

// Time encoding
type Time = {
  year   : [16],
  month  : [8],
  day    : [8],
  hour   : [8],
  minute : [8]
}

timeToDigits : Time -> [16][8]
timeToDigits time =
  yearDigits # sep # monthDigits # sep # dayDigits # sep # hourDigits # sep # minuteDigits
    where
  sep          = "+"
  yearDigits   = drop`{back=4} (toBase`{digits=5} decimal time.year)
  monthDigits  = drop`{back=2} (toBase`{digits=3} decimal time.month)
  dayDigits    = drop`{back=2} (toBase`{digits=3} decimal time.day)
  hourDigits   = drop`{back=2} (toBase`{digits=3} decimal time.hour)
  minuteDigits = drop`{back=2} (toBase`{digits=3} decimal time.minute)

digitsToTime : [16][8] -> Time
digitsToTime digits =
  if allSeparatorsValid
  then {year = year, month = month, day = day, hour = hour, minute = minute}
  else error "Invalid separator character in timestamp"
  where
    s1, s2, s3, s4 : [1][8]
    yearDigits : [4][8]
    monthDigits, dayDigits, hourDigits, minuteDigits : [2][8]

    yearDigits # s1 # monthDigits # s2 # dayDigits # s3 # hourDigits # s4 # minuteDigits = digits

    allSeparatorsValid = all (\s -> s == "+") [s1, s2, s3, s4]

    year   = fromBase decimal yearDigits
    month  = fromBase decimal monthDigits
    day    = fromBase decimal dayDigits
    hour   = fromBase decimal hourDigits
    minute = fromBase decimal minuteDigits

testTime = {
  year   = 2019,
  month  = 1,
  day    = 1,
  hour   = 1,
  minute = 1
}

// Ballot encoding
type Ballot contests positions
  = { time     : Time,
      unixTime : [6][8],
      contests : [contests][positions] }

encodeBallot :
  {contests, positions, encodedLength}
  (fin contests, fin positions,
   encodedLength == 16 + 16 * ((6 + (contests * positions) /^ 8) /^ 16)) =>
  [32][8] ->
  [32][8] ->
  [16][8] ->
  Ballot contests positions ->
  [1 + 16 + Base64Length encodedLength][8]
encodeBallot authKey ballotKey iv ballot =
  timeDigits # ":" # encodeBase64 (encryptedBallot # auth)
  where
    timeDigits      = timeToDigits ballot.time
    contestsBytes   = groupBy`{8} (padWith`{mod=8} zero (join ballot.contests))
    ballotBytes     = ballot.unixTime # contestsBytes
    encryptedBallot = encrypt ballotKey iv (padWith`{mod=16} zero ballotBytes)
    auth            = cbcMAC authKey zero (padWith`{mod=16} zero (timeDigits # encryptedBallot))

decodeBallot :
  {contests, positions, encodedLength}
  (fin contests, fin positions,
   encodedLength == 16 + 16 * ((6 + (contests * positions) /^ 8) /^ 16)) =>
  [32][8] ->
  [32][8] ->
  [16][8] ->
  [1 + 16 + Base64Length encodedLength][8] ->
  Ballot contests positions
decodeBallot authKey ballotKey iv encoded =
  if auth != recomputedAuth
  then error "Invalid authentication: ballot has been tampered with"
  | timeSep != ":"
  then error "Invalid time separator character"
  | contestPadding != zero
  then error "Non-zero padding in contest: did you ask for the right size ballot?"
  else { time = time, unixTime = unixTime, contests = contests }
  where
    timeSep : [1][8]
    timeDigits # timeSep # encryptedAndAuth = encoded

    time = digitsToTime timeDigits

    auth : [16][8]
    encryptedBallot # auth =
      decodeBase64`{encodedLength} encryptedAndAuth

    recomputedAuth =
      cbcMAC authKey zero (padWith`{mod=16} zero (timeDigits # encryptedBallot))

    unixTime # contestsBytes = decrypt ballotKey iv encryptedBallot

    contests : [contests][positions]
    contestBits # contestPadding = join contestsBytes
    contests = groupBy`{each=positions} contestBits

/*
decodeBallot :
  {contests, positions, encodedLength}
  (fin contests, fin positions,
   encodedLength == 16 + 16 * ((timeDigits + (contests * positions) /^ 8) /^ 16)) =>
  [32][8] ->
  [32][8] ->
  [16][8] ->
  [1 + timeDigits + Base64Length encodedLength][8] ->
  Ballot contests positions
decodeBallot authKey ballotKey iv encoded =
  if padding != zero
  then error "Invalid (non-zero) ballot padding"
  | auth != cbcMAC authKey zero (padWith`{mod=16} zero (groupBy`{8} time # encryptedBallot))
  then error "Invalid CBC-MAC authentication: this ballot has been tampered with!"
  | outerTimePadding != zero
  then error "Invalid plain text timestamp: out of range"
  | timePadding != zero
  then error "Invalid encrypted timestamp: out of range"
  | outerTime != time
  then error "Outer-inner timestamp mismatch: should be impossible with valid auth"
  else
  { time = time, contests = split contests }
  where
    outerTimeDigits : [timeDigits][8]
    encodedBallot : Base64 encodedLength
    outerTimeDigits # _ # encodedBallot = encoded

    auth : [16][8]
    encryptedBallot :
      [16 * ((timeDigits + (contests * positions) /^ 8) /^ 16)][8]
    encryptedBallot # auth =
      decodeBase64`{encodedLength} encodedBallot

    timeDigitsBits : [timeDigits * 8]
    contests : [contests * positions]

    timeDigitsBits # contests # padding =
      join (decrypt ballotKey iv encryptedBallot)

    time, outerTime               : [timeBytes * 8]
    timePadding, outerTimePadding : [width (10 ^^ timeDigits) - timeBytes * 8]

    timePadding      # time       = fromBase decimal (groupBy`{8} timeDigitsBits)
    outerTimePadding # outerTime  = fromBase decimal outerTimeDigits

// Proofs that ballot encoding is correct

ballot_roundtrip :
  {contests, positions} (fin contests, fin positions) =>
  [32][8] -> [32][8] -> [16][8] -> Ballot contests positions -> Bool
property ballot_roundtrip authKey ballotKey iv ballot =
  decodeBallot authKey ballotKey iv (encodeBallot authKey ballotKey iv ballot) == ballot
  */