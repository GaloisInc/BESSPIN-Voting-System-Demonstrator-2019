module AbstractBallotFormat where

import Base64 (encodeBase64, decodeBase64, Base64, Base64Length)
import Padding
import BaseConvert
import AESCBC

// Ballot encoding

parameter
  type timeBytes  : #   // how many bytes to represent the timestamp? (e.g. int32 => 4)
  type timeDigits : #   // how many decimal digits to represent the timestamp?
  type constraint (fin timeBytes, fin timeDigits,
                   timeBytes  >= 1, timeDigits >= 1,
                   // These constraints guarantee that the values above can
                   // represent each other properly
                   width (10 ^^ timeDigits) >= 8 * timeBytes,
                   10 ^^ timeDigits >= 2 ^^ (timeBytes * 8))

type Ballot contests positions
  = { time     : [timeBytes * 8],
      contests : [contests][positions] }

encodeBallot :
  {contests, positions, encodedLength}
  (fin contests, fin positions, fin timeDigits,
   encodedLength == 16 + 16 * ((timeDigits + (contests * positions) /^ 8) /^ 16)) =>
  [32][8] ->
  [32][8] ->
  [16][8] ->
  Ballot contests positions ->
  [1 + timeDigits + Base64Length encodedLength][8]
encodeBallot authKey ballotKey iv ballot =
  timeDigits # ":" # encodeBase64 (encryptedBallot # auth)
  where
    timeDigits      = toBase`{digits=timeDigits} decimal ballot.time
    timeBytes       = groupBy`{8} ballot.time
    contestsBytes   = groupBy`{8} (padWith`{mod=8} zero (join ballot.contests))
    ballotBytes     = timeDigits # contestsBytes
    encryptedBallot = encrypt ballotKey iv (padWith`{mod=16} zero ballotBytes)
    auth            = cbcMAC authKey zero (padWith`{mod=16} zero (timeBytes # encryptedBallot))

decodeBallot :
  {contests, positions, encodedLength}
  (fin contests, fin positions,
   encodedLength == 16 + 16 * ((timeDigits + (contests * positions) /^ 8) /^ 16)) =>
  [32][8] ->
  [32][8] ->
  [16][8] ->
  [1 + timeDigits + Base64Length encodedLength][8] ->
  Ballot contests positions
decodeBallot authKey ballotKey iv encoded =
  if padding != zero
  then error "Invalid (non-zero) ballot padding"
  | auth != cbcMAC authKey zero (padWith`{mod=16} zero (groupBy`{8} time # encryptedBallot))
  then error "Invalid CBC-MAC authentication: this ballot has been tampered with!"
  | outerTimePadding != zero
  then error "Invalid plain text timestamp: out of range"
  | timePadding != zero
  then error "Invalid encrypted timestamp: out of range"
  | outerTime != time
  then error "Outer-inner timestamp mismatch: should be impossible with valid auth"
  else
  { time = time, contests = split contests }
  where
    outerTimeDigits : [timeDigits][8]
    encodedBallot : Base64 encodedLength
    outerTimeDigits # _ # encodedBallot = encoded

    auth : [16][8]
    encryptedBallot :
      [16 * ((timeDigits + (contests * positions) /^ 8) /^ 16)][8]
    encryptedBallot # auth =
      decodeBase64`{encodedLength} encodedBallot

    timeDigitsBits : [timeDigits * 8]
    contests : [contests * positions]

    timeDigitsBits # contests # padding =
      join (decrypt ballotKey iv encryptedBallot)

    time, outerTime               : [timeBytes * 8]
    timePadding, outerTimePadding : [width (10 ^^ timeDigits) - timeBytes * 8]

    timePadding      # time       = fromBase decimal (groupBy`{8} timeDigitsBits)
    outerTimePadding # outerTime  = fromBase decimal outerTimeDigits

// Proofs that ballot encoding is correct

ballot_roundtrip :
  {contests, positions} (fin contests, fin positions) =>
  [32][8] -> [32][8] -> [16][8] -> Ballot contests positions -> Bool
property ballot_roundtrip authKey ballotKey iv ballot =
  decodeBallot authKey ballotKey iv (encodeBallot authKey ballotKey iv ballot) == ballot