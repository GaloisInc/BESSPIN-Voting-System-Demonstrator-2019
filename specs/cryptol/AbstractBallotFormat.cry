module AbstractBallotFormat where

import Base64 (encodeBase64, decodeBase64, Base64)
import Padding
import BaseConvert
import AESCBC

// Ballot encoding

parameter
  type timeBytes  : #
  type timeDigits : #
  type constraint (fin timeBytes, fin timeDigits,
                   timeBytes  >= 1, timeDigits >= 1,
                   width (10 ^^ timeDigits) >= 8 * timeBytes,
                   10 ^^ timeDigits >= 2 ^^ (timeBytes * 8))

type Ballot contests positions
  = { time     : [timeBytes * 8],
      contests : [contests][positions] }

// TODO:
// timestamp should be lifted out of base64 encoding, separated with ':'
// binary version of time digits go in MAC
// base64 everything minus time digits

encodeBallot :
  {contests, positions, encodedLength}
  (fin contests, fin positions, fin timeDigits,
   encodedLength == 16 + timeDigits +
     16 * ((timeDigits + (contests * positions) /^ 8) /^ 16)) =>
  [32][8] ->
  [32][8] ->
  [16][8] ->
  Ballot contests positions ->
  Base64 encodedLength
encodeBallot authKey ballotKey iv ballot =
  encodeBase64 (encryptedBallot # timeDigits # auth)
  where
    timeDigits      = toBase`{digits=timeDigits} decimal ballot.time
    contestsBytes   = groupBy`{8} (padWith`{mod=8} zero (join ballot.contests))
    ballotBytes     = timeDigits # contestsBytes
    encryptedBallot = encrypt ballotKey iv (padWith`{mod=16} zero ballotBytes)
    auth            = cbcMAC authKey zero (padWith`{mod=16} zero (encryptedBallot # timeDigits))

decodeBallot :
  {contests, positions, encodedLength}
  (fin contests, fin positions,
   encodedLength == 16 + timeDigits +
     16 * ((timeDigits + (contests * positions) /^ 8) /^ 16)) =>
  [32][8] ->
  [32][8] ->
  [16][8] ->
  Base64 encodedLength ->
  Ballot contests positions
decodeBallot authKey ballotKey iv encodedBallot =
  if padding != zero
  then error "Invalid (non-zero) ballot padding"
  | auth != cbcMAC authKey zero (padWith`{mod=16} zero (encryptedBallot # outerTimeDigits))
  then error "Invalid CBC-MAC authentication: this ballot has been tampered with!"
  | outerTimePadding != zero
  then error "Invalid outer timestamp: out of range"
  | timePadding != zero
  then error "Invalid timestamp: out of range"
  | outerTime != time
  then error "Outer-inner timestamp mismatch: should be impossible with valid auth"
  else
  { time = time, contests = split contests }
  where
    encryptedBallot :
      [16 * ((timeDigits + (contests * positions) /^ 8) /^ 16)][8]
    outerTimeDigits : [timeDigits][8]
    auth            : [16][8]

    encryptedBallot # outerTimeDigits # auth =
      decodeBase64`{encodedLength} encodedBallot

    timeBits   : [timeDigits * 8]
    contests   : [contests * positions]

    timeBits # contests # padding =
      join (decrypt ballotKey iv encryptedBallot)

    time, outerTime               : [timeBytes * 8]
    timePadding, outerTimePadding : [width (10 ^^ timeDigits) - timeBytes * 8]

    timePadding      # time       = fromBase decimal (groupBy`{8} timeBits)
    outerTimePadding # outerTime  = fromBase decimal outerTimeDigits

// Proofs that ballot encoding is correct

ballot_roundtrip :
  {contests, positions} (fin contests, fin positions) =>
  [32][8] -> [32][8] -> [16][8] -> Ballot contests positions -> Bool
property ballot_roundtrip authKey ballotKey iv ballot =
  decodeBallot authKey ballotKey iv (encodeBallot authKey ballotKey iv ballot) == ballot