// a number of contests where a unique candidate is selected for each contest

// we have a number nct of contests (0,1,...,nct-1) with ncd candidates (0,1,...,ncd-1) per contest.
// given a contest, a selection for candidate i, 0 <= i < ncd, is represented as "i:[width (ncd-1)]"
// a ballot is a vector of size nct where each entry is a bitvector of length "width (ncd-1)"
// there must be at least 2 candidates (and, of course, everything is finite)

type ballot nct ncd = [nct][width (ncd-1)]

type constraint ballot_constraint nct ncd = (fin nct, fin ncd, nct >= 1, ncd >= 2)

// a ballot is valid when each selection is a number between 0 and (ncd-1) included
is_valid : {nct, ncd} ballot_constraint nct ncd => ballot nct ncd -> Bit
is_valid b = all (\x -> x <= `(ncd-1)) [b@i | i <- [0..(nct-1)]]

// given a valid ballot, selection b ct == cd if and only if candidate cd is selected in contest ct
selection : {nct, ncd} ballot_constraint nct ncd => ballot nct ncd -> [width (nct-1)] -> [width (ncd-1)]
selection b ct = (b@ct)

// TODO: do we want to represent a ballot as an array of booleans instead?
// that is what ballot_2 specifies:

type ballot_2 nct ncd = [nct][ncd] // one bit per candidate

// a ballot is valid if and only if there is exactly one choice per contest
is_valid_2 : {nct, ncd} ballot_constraint nct ncd => ballot nct ncd -> Bit
is_valid_2 b = all valid b
  where valid x = x != zero /\ x && (x-1) == 0

// given a valid ballot, selection_2 b ct == cd if and only if candidate cd is selected in contest ct
selection_2 : {nct, ncd} ballot_constraint nct ncd => ballot nct ncd -> [width (nct-1)] -> [width (ncd-1)]
selection_2 b ct = (last xs).1 
  where xs = [(False, 0)] # [
    if stop then (stop,cd) else (if (b@ct@i) then (True, i) else (False,0)) 
    | i <- [0..ncd-1] 
    | (stop,cd) <- xs ]
