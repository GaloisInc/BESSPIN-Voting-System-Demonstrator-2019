module Log where

import Base64

parameter

    /** This defines the output size of the hash (TODO: the hash _function_?) in bytes.
        For our use it is expected we will use SHA256 and
        this will be instantiated as 32
    */

    type HashSizeBytes : #

    /**
        We cannot use a hash function that outputs a stream
    */
    type constraint fin HashSizeBytes

    /**
        The hash size must be bigger than the output of the CBC-MAC used on
        the initial message
    */
    type constraint HashSizeBytes >= 16

    /**
        Our hash function must take in an arbitrary number
        of bytes (n) and output the hash size of bytes
    */
    hash : {n} (fin n) => [n][8] -> [HashSizeBytes][8]

    //cbcMac block size in bytes 
    //type CbcMACBlockSizeBytes : #
    //type constraint CbcMACBlockSizeBytes >= 1
    //type constraint fin CbcMACBlockSizeBytes

    /**
        We also need the CBC-MAC function.
    */
    cbcMAC : {msgSizeBytes, keySizeBytes} (fin msgSizeBytes, fin keySizeBytes, msgSizeBytes % CbcMACBlockSizeBytes == 0) =>
        [keySizeBytes][8] ->
        [msgSizeBytes][8] ->
        [16][8] //cbcMAC with AES always has 128 bit output, regardless of keysize

type CbcMACBlockSizeBytes = 16
/**
    A log entry. The msgHash should always be the hash of the message,
    unless it's the first entry in which case it should be the MAC (TODO: of the padded message?)
*/
type Log sizeBytes = {
    message : [sizeBytes][8],
    msgHash : [HashSizeBytes][8],
    logMAC  : [16][8]
}

serializeBinaryLog : {sizeBytes} (fin sizeBytes) =>
    Log sizeBytes -> [sizeBytes + HashSizeBytes + 16][8]
serializeBinaryLog log = log.message # log.msgHash # log.logMAC

/* In ASCII format, the hash is Base64 encoded, and we add FOUR characters for */
/* readability - a space between each field and \r\n on the end                */
serializeASCIILog : {sizeBytes} (fin sizeBytes) =>
    Log sizeBytes -> [_][8]
serializeASCIILog log = log.message # [' '] # (encodeBase64 log.msgHash) # [' '] # (encodeBase64 log.logMAC) # ['\r'] # ['\n']

/**
    A log file is a series of log messages. We must
    specify a maximum log size so that all of the entries
    can have the same type
*/
type LogFile maxSizeBytes msgs = [msgs](Log maxSizeBytes)

serializeBinaryLogFile : {maxSizeBytes, msgs} (fin maxSizeBytes, fin msgs, msgs >= 1) =>
    LogFile maxSizeBytes msgs ->
    [msgs * (maxSizeBytes + HashSizeBytes + 16)][8]
serializeBinaryLogFile logFile = join serializedLogs where
    serializedLogs = [serializeBinaryLog entry | entry <- logFile]

serializeASCIILogFile : {maxSizeBytes, msgs} (fin maxSizeBytes, fin msgs, msgs >= 1) =>
    LogFile maxSizeBytes msgs ->
    [msgs * (maxSizeBytes + Base64Length HashSizeBytes + Base64Length 16 + 4)][8]
serializeASCIILogFile logFile = join serializedLogs where
    serializedLogs = [serializeASCIILog entry | entry <- logFile]

/**
  The smallest multiple of CbcMACBlockSizeBytes that is strictly bigger than `a+b`
*/
type LogMACArgLength a b = (CbcMACBlockSizeBytes * ((a + b + 1) /^ CbcMACBlockSizeBytes))

//Message will be something from secure boot, not identified yet
initialLogEntry : {msgSize, keySize, maxMsgSize}
                (fin msgSize, fin keySize, fin maxMsgSize, maxMsgSize % CbcMACBlockSizeBytes == 0, msgSize <= maxMsgSize) => 
    [keySize][8] -> [msgSize][8] -> Log maxMsgSize
initialLogEntry key msg = 
// TODO: how should we pad msgHash below?
    { message = paddedMsg, msgHash = msgHash # TODO1, logMAC = cbcMAC key logMACArg} where
        logMACArg = ((paddedMsg # (repeat padChar) # (encodeBase64 msgHash)):[LogMACArgLength maxMsgSize (Base64Length HashSizeBytes)][8])
        paddedMsg = ((msg # (repeat padChar)) : [maxMsgSize][8])
        msgHash = cbcMAC key paddedMsg // TODO: this implies that maxMsgSize is a multiple of 16. I added this as a type constraint but should we pad instead?
    where
      TODO1 = repeat padChar

/**
    Utility function to get the previous hash
*/
getLastHash : {sizeBytes, msgs} (fin msgs, msgs >= 1) => LogFile sizeBytes msgs -> [HashSizeBytes][8]
getLastHash logs = (logs ! 0).msgHash

/**
    Update a log with a new entry
    We require the number of messages to be >= 1 because
    this operation should not be used for the first message
*/
updateLog : {msgSize, keySize, maxMsgSize, msgs}
    (fin msgSize, fin keySize, msgSize <= maxMsgSize, fin msgs, fin maxMsgSize, msgs >=1) =>
    (LogFile maxMsgSize msgs) ->
    [keySize][8] ->
    [msgSize][8] ->
    LogFile maxMsgSize (msgs + 1)
updateLog log key msg = log # [newEntry] where
    paddedMsg = msg # (repeat padChar)
    previousHash = getLastHash log
    newEntry = {message = paddedMsg, msgHash = msgHash, logMAC = (cbcMAC key logMACArg)}
    logMACArg = ((paddedMsg # (repeat padChar) # (encodeBase64 msgHash)):[LogMACArgLength maxMsgSize (Base64Length HashSizeBytes)][8])
    msgHash = hash (paddedMsg # previousHash)

/**
    Given a log entry, check to see if it is a valid first entry
*/
validFirstEntry : {msgSizeBytes, keySizeBytes}
    (fin msgSizeBytes, fin keySizeBytes) =>
    Log msgSizeBytes ->
    [keySizeBytes][8] ->
    Bit
property validFirstEntry log key = log.msgHash == (cbcMAC key log.message # zero) /\ log.logMAC == cbcMAC key (log.message # log.msgHash)
/* NOTE: the CBC MAC part of this check need not be performed on the smart ballot box */

/**
    Check to see if a log entry is valid given the previous hash
*/
validLogEntry : {msgSizeBytes, keySize}
    (fin msgSizeBytes, fin keySize) =>
    Log msgSizeBytes ->
    [keySize][8] ->
    [HashSizeBytes][8] ->
    Bit
property validLogEntry log key prevHash =
    log.msgHash == hash (log.message # prevHash) /\ log.logMAC == cbcMAC key (log.message # log.msgHash)
/* NOTE: the CBC MAC part of this check need not be performed on the smart ballot box */

/**
Check the validity of an entire log file relative to a key
*/
validLogFile : {maxMsgSize, keySize, msgs}
    (fin maxMsgSize, fin keySize, fin msgs) =>
    LogFile maxMsgSize msgs ->
    [keySize][8] ->
    Bit
property validLogFile logFile key =
    `msgs == (0 : [width msgs]) \/
    (foldResult ! 0 where
        foldResult = [validFirstEntry (logFile @ 0) key] #
                        [prevValid /\ validLogEntry log key (prevLog.msgHash)
                            | log <- logFile
                            | prevLog <- [zero] # logFile
                            | prevValid <- foldResult])
