module SBB where

id : {a} a -> a
id x = x

compose : {a, b, c} (b -> c) -> (a -> b) -> (a -> c)
compose f g x = f (g x)

(>>) : {a, b, c} (a -> b) -> (b -> c) -> (a -> c)
(>>) f g x = g (f x)

(>>=) : {a, b, c, v} (a -> (b, v)) -> (v -> b -> c) -> (a -> c)
(>>=) f g a = c
  where
    (b, v) = f a
    c      = g v b

parameter
  type RealWorld      : *
  type TickTypeSize   : #
  type constraint (fin TickTypeSize, TickTypeSize >= 16)
  assertFalse         : {a} () -> a
  getBarcode          : {l} RealWorld -> String l
  getBarcodeLength    : RealWorld -> BarcodeLength
  realWorldBool       : RealWorld -> (RealWorld, Bool)
  ballotDetectTimeout : RealWorld -> (RealWorld, [TickTypeSize])
  osdGetTicks         : RealWorld -> (RealWorld, [TickTypeSize])

/**************************************** votingdefs.h ****************************************/

osdMSecToTicks x = x

/**************************************** sbb_t.h ****************************************/

type BarcodeLength = [8] // TODO: check this

type TickType = [TickTypeSize]

type GlobalState =
  { ballotDetectTimeout : TickType
  , barcodeLength       : BarcodeLength
  // can't store barcode here, so it's a primitive instead
  , castOrSpoilTimeout  : TickType
  }

type State =
  { worldState  : RealWorld
  , globalState : GlobalState
  , sbbState    : SBBState
  }

type StateTransformer = State -> State
type StateTransformerReturning a = State -> (State, a)

updateWorldState : (RealWorld -> RealWorld) -> StateTransformer
updateWorldState f s = { s | worldState -> f worldState }

setWorldState : RealWorld -> StateTransformer
setWorldState w s = { s | worldState = w }

updateGlobalState : (GlobalState -> GlobalState) -> StateTransformer
updateGlobalState f s = { s | globalState -> f globalState }

updateSBBState : (SBBState -> SBBState) -> StateTransformer
updateSBBState f s = { s | sbbState -> f sbbState }

wrapRealWorldBool : StateTransformerReturning Bool
wrapRealWorldBool s = (setWorldState w s, b)
  where
    (w, b) = realWorldBool s.worldState

type SDCardState   = { SDCardState : [8] }
UnknownSDCardState = { SDCardState = 0x00 }
SDCardReady        = { SDCardState = 0x01 }

type TimerState = { TimerState : [8] }
Initialized     = { TimerState = SDCardReady.SDCardState + 0x01 }
Running         = { TimerState = SDCardReady.SDCardState + 0x02 }
Stopped         = { TimerState = SDCardReady.SDCardState + 0x03 }

type MotorState       = { MotorState : [8] }
MotorsOff             = { MotorState = Stopped.TimerState + 0x01 }
MotorsTurningForward  = { MotorState = Stopped.TimerState + 0x02 }
MotorsTurningBackward = { MotorState = Stopped.TimerState + 0x03 }

type DisplayState  = { DisplayState : [8] }
Initialization     = { DisplayState = MotorsTurningBackward.MotorState + 0x01 }
InitializedDisplay = { DisplayState = MotorsTurningBackward.MotorState + 0x02 }
ShowingText        = { DisplayState = MotorsTurningBackward.MotorState + 0x03 }

type PaperDetectState = { PaperDetectState : [8] }
NoPaperDetected       = { PaperDetectState = ShowingText.DisplayState + 0x01 }
PaperDetected         = { PaperDetectState = ShowingText.DisplayState + 0x02 }

type ButtonsState = { ButtonsState : [8] }
AllButtonsUp      = { ButtonsState = PaperDetected.PaperDetectState + 0x01 }
SpoilButtonDown   = { ButtonsState = PaperDetected.PaperDetectState + 0x02 }
CastButtonDown    = { ButtonsState = PaperDetected.PaperDetectState + 0x03 }

type BarcodeScannerState  = { BarcodeScannerState : [8] }
BarcodeNotPresent         = { BarcodeScannerState = CastButtonDown.ButtonsState + 0x01 }
BarcodePresentAndRecorded = { BarcodeScannerState = CastButtonDown.ButtonsState + 0x02 }

type LogState = { LogState : [8] }
LogOK         = { LogState = BarcodePresentAndRecorded.BarcodeScannerState + 0x01 }
LogFailure    = { LogState = BarcodePresentAndRecorded.BarcodeScannerState + 0x02 }

type LogicState = { LogicState : [8] }
Initialize      = { LogicState = LogFailure.LogState + 0x01 }
Standby         = { LogicState = LogFailure.LogState + 0x02 }
WaitForBallot   = { LogicState = LogFailure.LogState + 0x03 }
FeedBallot      = { LogicState = LogFailure.LogState + 0x04 }
BarcodeDetected = { LogicState = LogFailure.LogState + 0x05 }
WaitForDecision = { LogicState = LogFailure.LogState + 0x06 }
Cast            = { LogicState = LogFailure.LogState + 0x07 }
Spoil           = { LogicState = LogFailure.LogState + 0x08 }
Eject           = { LogicState = LogFailure.LogState + 0x09 }
AwaitRemoval    = { LogicState = LogFailure.LogState + 0x0A }
Abort           = { LogicState = LogFailure.LogState + 0x0B }

type StartStopState = { StartStopState : [8] }
Start               = { StartStopState = Abort.LogicState + 0x01 }
Inner               = { StartStopState = Abort.LogicState + 0x02 }
Stop                = { StartStopState = Abort.LogicState + 0x03 }

type SBBEvent        = { SBBEvent : [8] }
MotorOffE            = { SBBEvent = Stop.StartStopState + 0x01 }
MotorForwardE        = { SBBEvent = Stop.StartStopState + 0x02 }
MotorBackwardE       = { SBBEvent = Stop.StartStopState + 0x03 }
CardPresentE         = { SBBEvent = Stop.StartStopState + 0x04 }
EraseCardE           = { SBBEvent = Stop.StartStopState + 0x05 }
InternalBarcodeE     = { SBBEvent = Stop.StartStopState + 0x06 }
InternalDisplayE     = { SBBEvent = Stop.StartStopState + 0x07 }
DisplayTextE         = { SBBEvent = Stop.StartStopState + 0x08 }
InternalPaperDetectE = { SBBEvent = Stop.StartStopState + 0x09 }
SpoilE               = { SBBEvent = Stop.StartStopState + 0x0A }
CastE                = { SBBEvent = Stop.StartStopState + 0x0B }
InternalCastSpoilE   = { SBBEvent = Stop.StartStopState + 0x0C }
InternalTimerE       = { SBBEvent = Stop.StartStopState + 0x0D }
TimerTickUnderE      = { SBBEvent = Stop.StartStopState + 0x0E }
TimerTickOverE       = { SBBEvent = Stop.StartStopState + 0x0F }
ResetTimerE          = { SBBEvent = Stop.StartStopState + 0x10 }
InternalControllerE  = { SBBEvent = Stop.StartStopState + 0x11 }

type BarcodeValidity = { BarcodeValidity : [3] }
BarcodeValid            = { BarcodeValidity = 0 }
BarcodeInvalidLength    = { BarcodeValidity = 1 }
BarcodeInvalidEncoding  = { BarcodeValidity = 2 }
BarcodeInvalidSignature = { BarcodeValidity = 3 }
BarcodeInvalidTimestamp = { BarcodeValidity = 4 }
BarcodeInvalidOther     = { BarcodeValidity = 5 }

type SBBState =
    { C                  : SDCardState
    , T                  : TimerState
    , M                  : MotorState
    , D                  : DisplayState
    , P                  : PaperDetectState
    , B                  : ButtonsState
    , BS                 : BarcodeScannerState
    , S                  : StartStopState
    , FS                 : LogState
    , L                  : LogicState
    , ButtonIllumination : [2]
    }

/**************************************** sbb.c ****************************************/

ballotDetectTimeoutMS = 10000
castOrSpoilTimeoutMS  = 30000

initialize : StateTransformerReturning Bool
initialize s = (updateSBBState (\ sbb -> { sbb | M = MotorsOff }) s, True)

// FIXME: this is placeholder silly code
isBarcodeValid : {barcodeLength} String barcodeLength -> BarcodeLength -> BarcodeValidity
isBarcodeValid barcode barcode_length =
  if barcode_length == 0
  then BarcodeInvalidOther
  else
  if barcode_length == 1
  then BarcodeValid
  else BarcodeInvalidLength

isCastButtonPressed : SBBState -> Bool
isCastButtonPressed s = s.B == CastButtonDown

isSpoilButtonPressed : SBBState -> Bool
isSpoilButtonPressed s = s.B == SpoilButtonDown

hasABarcode : SBBState -> Bool
hasABarcode s = s.BS == BarcodePresentAndRecorded

castButtonMask : [2]
castButtonMask = 1 << 0

spoilButtonMask : [2]
spoilButtonMask = 1 << 1

spoilButtonLightOn : StateTransformer
spoilButtonLightOn = updateSBBState (\ sbb ->
    { sbb | ButtonIllumination -> ButtonIllumination || spoilButtonMask }
  )

spoilButtonLightOff : StateTransformer
spoilButtonLightOff = updateSBBState (\ sbb ->
    { sbb | ButtonIllumination -> ButtonIllumination && ~spoilButtonMask }
  )

castButtonLightOn : StateTransformer
castButtonLightOn = updateSBBState (\ sbb ->
    { sbb | ButtonIllumination -> ButtonIllumination || castButtonMask }
  )

castButtonLightOff : StateTransformer
castButtonLightOff = updateSBBState (\ sbb ->
    { sbb | ButtonIllumination -> ButtonIllumination && ~castButtonMask }
  )

moveMotorForward : StateTransformer
moveMotorForward = updateSBBState (\ sbb -> { sbb | M = MotorsTurningForward })

moveMotorBackward : StateTransformer
moveMotorBackward = updateSBBState (\ sbb -> { sbb | M = MotorsTurningBackward })

stopMotor : StateTransformer
stopMotor = updateSBBState (\ sbb -> { sbb | M = MotorsOff })

ballotDetected : SBBState -> Bool
ballotDetected s = s.P == PaperDetected

ejectBallot : StateTransformer
ejectBallot = moveMotorBackward >> stopMotor

spoilBallot : StateTransformer
spoilBallot = spoilButtonLightOff >> castButtonLightOff >> ejectBallot

castBallot : StateTransformer
castBallot = moveMotorForward >> stopMotor

goToStandby : StateTransformer
goToStandby =
  (\ s ->
     if s.sbbState.M == MotorsOff
     then s
     else stopMotor s
  )
  >> castButtonLightOff
  >> spoilButtonLightOff
  >> updateSBBState (\ sbb ->
     { sbb | D  = ShowingText
           , P  = NoPaperDetected
           , BS = BarcodeNotPresent
           , B  = AllButtonsUp
           , L  = Standby
           , S  = Inner
     }
  )

ballotDetectTimeoutReset : StateTransformer
ballotDetectTimeoutReset s =
  { s | worldState = w
      , globalState -> { globalState | ballotDetectTimeout = timeout }
  }
  where
    (w, ticks) = osdGetTicks w
    timeout    = ticks + osdMSecToTicks ballotDetectTimeoutMS

ballotDetectTimeoutExpired : StateTransformerReturning Bool
ballotDetectTimeoutExpired s = (setWorldState w s, b)
  where
    (w, ticks) = osdGetTicks s.worldState
    timeout    = s.globalState.ballotDetectTimeout
    b = ticks > timeout

castOrSpoilTimeoutReset : StateTransformer
castOrSpoilTimeoutReset s =
  { s | worldState = w
      , globalState -> { globalState | castOrSpoilTimeout = timeout }
  }
  where
    (w, ticks) = osdGetTicks w
    timeout    = ticks + osdMSecToTicks castOrSpoilTimeoutMS

castOrSpoilTimeoutExpired : StateTransformerReturning Bool
castOrSpoilTimeoutExpired s = (setWorldState w s, b)
  where
    (w, ticks) = osdGetTicks s.worldState
    timeout    = s.globalState.castOrSpoilTimeout
    b = ticks > timeout

/**************************************** sbb_machine.c ****************************************/

updatePaperState : Bool -> Bool -> StateTransformer
updatePaperState paperInPressed paperInReleased s =
  if (s.sbbState.L == Initialize) && paperInPressed
  then updateSBBState (\ sbb -> { sbb | P = PaperDetected }) s
  else
  if s.sbbState.P == NoPaperDetected
  then if paperInPressed
       then updateSBBState (\ sbb -> { sbb | P = PaperDetected }) s
       else s
  else
  if s.sbbState.P == PaperDetected
  then if paperInReleased
       then updateSBBState (\ sbb -> { sbb | P = NoPaperDetected }) s
       else s
  else s

updateButtonState : Bool -> Bool -> Bool -> Bool -> StateTransformer
updateButtonState castButtonPressed castButtonReleased spoilButtonPressed spoilButtonReleased s =
  if s.sbbState.B == AllButtonsUp
  then if castButtonPressed
       then updateSBBState (\ sbb -> { sbb | B = CastButtonDown }) s
       else
       if spoilButtonPressed
       then updateSBBState (\ sbb -> { sbb | B = SpoilButtonDown }) s
       else s
  else
  if s.sbbState.B == CastButtonDown
  then if castButtonReleased
       then updateSBBState (\ sbb -> { sbb | B = AllButtonsUp }) s
       else s
  else
  if s.sbbState.B == SpoilButtonDown
  then if spoilButtonReleased
       then updateSBBState (\ sbb -> { sbb | B = AllButtonsUp }) s
       else s
  else s

updateBarcodeState : Bool -> StateTransformer
updateBarcodeState barcodeScanned s =
  if s.sbbState.BS == BarcodeNotPresent
  then if barcodeScanned
       then (
         wrapRealWorldBool >>= (\ barcodeReceived ->
           if barcodeReceived
           then updateSBBState (\ sbb -> { sbb | BS = BarcodePresentAndRecorded })
           else id
         )
       ) s
       else s
  else s

flushBarcodes : StateTransformer
flushBarcodes =
  updateSBBState (\ sbb -> { sbb | BS = BarcodeNotPresent })
  >> updateSensorState
  >> (\ s ->
     if s.sbbState.BS == BarcodePresentAndRecorded
     then flushBarcodes s
     else s
  )

updateSensorState : StateTransformer
updateSensorState =
  (
    wrapRealWorldBool >>= (\ b1 ->
      wrapRealWorldBool >>= (\ b2 ->
        updatePaperState b1 b2
      )
    )
  )
  >>
  (
    wrapRealWorldBool >>= (\ b1 ->
      wrapRealWorldBool >>= (\ b2 ->
        wrapRealWorldBool >>= (\ b3 ->
          wrapRealWorldBool >>= (\ b4 ->
            updateButtonState b1 b2 b3 b4
          )
        )
      )
    )
  )
  >>
  (
    wrapRealWorldBool >>= (\ b ->
      updateBarcodeState b
    )
  )

runAwaitRemoval : StateTransformer
runAwaitRemoval s =
  if ~ ballotDetected s.sbbState
  then updateSBBState (\ sbb ->  { sbb | L = Standby }) s
  else s

runEject : StateTransformer
runEject = ejectBallot >> updateSBBState (\ sbb -> { sbb | L = AwaitRemoval })

runSpoil : StateTransformer
runSpoil = spoilBallot >> updateSBBState (\ sbb -> { sbb | L = AwaitRemoval })

runCast : StateTransformer
runCast = castBallot >> updateSBBState (\ sbb -> { sbb | L = Standby })

runWaitForDecision : StateTransformer
runWaitForDecision s =
  (
    castOrSpoilTimeoutExpired >>= (\ b ->
      if b
      then (
        spoilButtonLightOff
        >>
        castButtonLightOff
        >>
        updateSBBState (\ sbb -> { sbb | L = Eject })
      )
      else
      if isCastButtonPressed s.sbbState
      then (
        wrapRealWorldBool >>= (\ b1 ->
          if ~ b1
          then updateSBBState (\ sbb -> { sbb | L = Abort })
          else updateSBBState (\ sbb -> { sbb | L = Cast })
        )
        >>
        spoilButtonLightOff
        >>
        castButtonLightOff
      )
      else
      if isSpoilButtonPressed s.sbbState
      then (
        wrapRealWorldBool >>= (\ b1 ->
          if ~ b1
          then updateSBBState (\ sbb -> { sbb | L = Abort })
          else updateSBBState (\ sbb -> { sbb | L = Spoil })
        )
        >>
        spoilButtonLightOff
        >>
        castButtonLightOff
      )
      else id
    )
  ) s
  where
    barcode_length = getBarcodeLength s.worldState
    barcode        = getBarcode s.worldState

barcodeCastOrSpoiled :
  { barcodeLength }
  String barcodeLength ->
  BarcodeLength ->
  StateTransformerReturning Bool
barcodeCastOrSpoiled barcode barcode_length = wrapRealWorldBool

runBarcodeDetected : StateTransformer
runBarcodeDetected s =
  (
    barcodeCastOrSpoiled barcode barcode_length >>= (\ b ->
      if b
      then updateSBBState (\ sbb -> { sbb | L = Eject })
      else
      if validity == BarcodeValid
      then (
        castButtonLightOn
        >> spoilButtonLightOn
        >> castOrSpoilTimeoutReset
        >> updateSBBState (\ sbb -> { sbb | L = WaitForDecision })
      )
      else
      if validity == BarcodeInvalidTimestamp
      then updateSBBState (\ sbb -> { sbb | L = Eject })
      else updateSBBState (\ sbb -> { sbb | L = Eject })
    )
  ) s
  where
    barcode_length = getBarcodeLength s.worldState
    barcode        = getBarcode s.worldState
    validity       = isBarcodeValid barcode barcode_length

runFeedBallot : StateTransformer
runFeedBallot =
  ballotDetectTimeoutExpired >>= (\ timeout s ->
    if (~ ballotDetected s.sbbState) || timeout
    then (
      stopMotor
      >>
      (\ s1 ->
        if hasABarcode s1.sbbState
        then updateSBBState (\ sbb -> { sbb | L = BarcodeDetected }) s1
        else updateSBBState (\ sbb -> { sbb | L = Eject }) s1
      )
    ) s
    else s
  )

runWaitForBallot : StateTransformer
runWaitForBallot =
  ballotDetectTimeoutReset
  >> moveMotorForward
  >> updateSBBState (\ s -> { s | L = FeedBallot })

loadOrCreateLogs : StateTransformerReturning Bool
loadOrCreateLogs = wrapRealWorldBool

runInitialize : StateTransformer
runInitialize =
  initialize >>= (\ initOK ->
    if initOK
    then (
      loadOrCreateLogs >>= (\ logCreated ->
        if logCreated
        then (
          updateSensorState
          >> (\ s ->
            if ballotDetected s.sbbState
            then updateSBBState (\ sbb -> { sbb | L = Eject }) s
            else updateSBBState (\ sbb -> { sbb | L = Standby }) s
          )
        )
        else updateSBBState (\ sbb -> { sbb | L = Abort })
      )
    )
    else updateSBBState (\ sbb -> { sbb | L = Abort })
  )

runStandby : StateTransformer
runStandby =
  flushBarcodes
  >> goToStandby
  >> updateSBBState (\ sbb -> { sbb | L = WaitForBallot })

runAbort : StateTransformer
runAbort = id

takeStep : StateTransformer
takeStep s =
  if s.sbbState.L == Standby
  then runStandby s
  else
  if s.sbbState.L == WaitForBallot
  then runWaitForBallot s
  else
  if s.sbbState.L == FeedBallot
  then runFeedBallot s
  else
  if s.sbbState.L == BarcodeDetected
  then runBarcodeDetected s
  else
  if s.sbbState.L == WaitForDecision
  then runWaitForDecision s
  else
  if s.sbbState.L == Cast
  then runCast s
  else
  if s.sbbState.L == Spoil
  then runSpoil s
  else
  if s.sbbState.L == Eject
  then runEject s
  else
  if s.sbbState.L == AwaitRemoval
  then runAwaitRemoval s
  else
  if s.sbbState.L == Abort
  then (\ _ -> assertFalse ()) (runAbort s)
  else s

/**********************************************************************/

dummySBBState : SBBState
dummySBBState =
  { C                  = UnknownSDCardState
  , T                  = Stopped
  , M                  = MotorsOff
  , D                  = Initialization
  , P                  = NoPaperDetected
  , B                  = AllButtonsUp
  , BS                 = BarcodeNotPresent
  , S                  = Start
  , FS                 = LogOK
  , L                  = Initialize
  , ButtonIllumination = 0
  }

// test = spoilButtonLightOn dummySBBState
