/**
 * Smart Ballot Box ACSL specification
 * @refine sbb.lando
 */

#ifndef __SBB_API_ACSL__
#define __SBB_API_ACSL__

#include "sbb_t.h"

// @spec kiniry What follows is an algebraic description of the SBB hardware.

/*@ axiomatic button {
  @   type button = down | up;
  @ }
  @ axiomatic light {
  @   type light = lit | dark;
  @ }
  @ axiomatic barcode_present {
  @   type has_barcode = yes | no;
  @ }
  @ axiomatic motor {
  @   type motor = forward | backward | off;
  @ }
  @ axiomatic SBB_hardware {
  @   type cast_button = button;
  @   type spoil_button = button;
  @   type cast_button_light = light;
  @   type spoil_button_light = light;
  @   type paper_feed_motor = motor;
  @   logic boolean lights_off(cast_button_light cbl, spoil_button_light sbl) =
  @     cbl == dark && sbl == dark;
  @   logic boolean buttons_up(cast_button cb, spoil_button sb) =
  @     cb == up && sb == up;
  @   logic boolean motor_running(motor m) = m != off;
  @ }
*/

// @design kiniry Note that when the SBB is powered on, a ballot paper
// may be inside of the device.  We cannot make assumptions about
// initial button state as they may get physically stuck or someone
// can hold them down during reset.  This spec is currently not quite
// right because it will only hold after `initialize()` is called.

/*@ global invariant buttons_initial_state:
  @   \forall cast_button_light cbl, spoil_button_light sbl;
  @   \at(lights_off(cbl, sbl), Init);
  @ global invariant motor_initial_state: \forall motor m;
  @   \at(!motor_running(m), Init);
*/

#endif
