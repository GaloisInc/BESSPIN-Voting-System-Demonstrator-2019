/**
 * Smart Ballot Box ACSL specification
 * @refine sbb.lando
 */

#ifndef __SBB_API_ACSL__
#define __SBB_API_ACSL__

#include "sbb_t.h"

// @spec kiniry What follows is an algebraic description of the SBB hardware.

/*@ axiomatic button {
  @   type button = down | up;
  @ }
  @ axiomatic light {
  @   type light = lit | dark;
  @ }
  @ axiomatic barcode_present {
  @   type has_barcode = yes | no;
  @ }
  @ axiomatic motor {
  @   type motor = forward | backward | off;
  @ }
  @ axiomatic SBB_hardware {
  @   type cast_button = button;
  @   type spoil_button = button;
  @   type cast_button_light = light;
  @   type spoil_button_light = light;
  @   type paper_feed_motor = motor;
  @   predicate lights_off(cast_button_light cbl,
  @                        spoil_button_light sbl,
  @                        SBB_state S) =
  @     (cbl == dark && sbl == dark) <==> no_buttons_lit(S);
  @   predicate buttons_up(cast_button cb, spoil_button sb, SBB_state S) =
  @     (cb == up && sb == up) <==> (S.B == ALL_BUTTONS_UP);
  @   predicate motor_running(motor m, SBB_state S) =
        (m != off) <==> (S.M.MOTORS_TURNING_FORWARD);
  @ }
*/

// @design kiniry Note that when the SBB is powered on, a ballot paper
// may be inside of the device.  We cannot make assumptions about
// initial button state as they may get physically stuck or someone
// can hold them down during reset.  This spec is currently not quite
// right because it will only hold after `initialize()` is called.

/*  global invariant buttons_initial_state:
  @   \forall cast_button_light cbl, spoil_button_light sbl;
  @   \at(lights_off(cbl, sbl), Init);
  @ global invariant motor_initial_state: \forall motor m;
  @   \at(!motor_running(m), Init);
*/

#endif
