(**************************************************************************)
(*                                                                        *)
(*  The Why3 Verification Platform   /   The Why3 Development Team        *)
(*  Copyright 2010-2013   --   INRIA - CNRS - Paris-Sud University        *)
(*                                                                        *)
(*  This software is distributed under the terms of the GNU Lesser        *)
(*  General Public License version 2.1, with the special exception        *)
(*  on linking described in file LICENSE.                                 *)
(*                                                                        *)
(*  File modified by CEA (Commissariat à l'énergie atomique et aux        *)
(*                        énergies alternatives).                         *)
(*                                                                        *)
(**************************************************************************)

(* this is the prelude for Alt-Ergo, version >= 0.95.2 *)
(* this is a prelude for Alt-Ergo integer arithmetic *)
(** The theory BuiltIn_ must be appended to this file*)
(** The theory Bool_ must be appended to this file*)
(**************************************************************************)
(*                                                                        *)
(*  The Why3 Verification Platform   /   The Why3 Development Team        *)
(*  Copyright 2010-2013   --   INRIA - CNRS - Paris-Sud University        *)
(*                                                                        *)
(*  This software is distributed under the terms of the GNU Lesser        *)
(*  General Public License version 2.1, with the special exception        *)
(*  on linking described in file LICENSE.                                 *)
(*                                                                        *)
(*  File modified by CEA (Commissariat à l'énergie atomique et aux        *)
(*                        énergies alternatives).                         *)
(*                                                                        *)
(**************************************************************************)

(* this is the prelude for Alt-Ergo, version >= 0.95.2 *)
(** The theory BuiltIn_ must be appended to this file*)
(** The theory Bool_ must be appended to this file*)
(** The theory int_Int_ must be appended to this file*)
logic abs_int : int -> int

axiom abs_def : (forall x:int. ((0 <= x) -> (abs_int(x) = x)))

axiom abs_def1 : (forall x:int. ((not (0 <= x)) -> (abs_int(x) = (-x))))

axiom Abs_le :
  (forall x:int. forall y:int. ((abs_int(x) <= y) -> ((-y) <= x)))

axiom Abs_le1 : (forall x:int. forall y:int. ((abs_int(x) <= y) -> (x <= y)))

axiom Abs_le2 :
  (forall x:int. forall y:int. ((((-y) <= x) and (x <= y)) ->
  (abs_int(x) <= y)))

axiom Abs_pos : (forall x:int. (0 <= abs_int(x)))

(**************************************************************************)
(*                                                                        *)
(*  The Why3 Verification Platform   /   The Why3 Development Team        *)
(*  Copyright 2010-2013   --   INRIA - CNRS - Paris-Sud University        *)
(*                                                                        *)
(*  This software is distributed under the terms of the GNU Lesser        *)
(*  General Public License version 2.1, with the special exception        *)
(*  on linking described in file LICENSE.                                 *)
(*                                                                        *)
(*  File modified by CEA (Commissariat à l'énergie atomique et aux        *)
(*                        énergies alternatives).                         *)
(*                                                                        *)
(**************************************************************************)

(* this is the prelude for Alt-Ergo, version >= 0.95.2 *)
logic comp_div: int, int -> int
axiom comp_div_def: forall x, y:int. x >= 0 and y > 0 -> comp_div(x,y) = x / y
logic comp_mod: int, int -> int
axiom comp_mod_def: forall x, y:int. x >= 0 and y > 0 -> comp_mod(x,y) = x % y
(** The theory BuiltIn_ must be appended to this file*)
(** The theory Bool_ must be appended to this file*)
(** The theory int_Int_ must be appended to this file*)
(** The theory int_Abs_ must be appended to this file*)
axiom Div_bound :
  (forall x:int. forall y:int. (((0 <= x) and (0 <  y)) ->
  (0 <= comp_div(x,y))))

axiom Div_bound1 :
  (forall x:int. forall y:int. (((0 <= x) and (0 <  y)) ->
  (comp_div(x,y) <= x)))

axiom Div_1 : (forall x:int. (comp_div(x,1) = x))

axiom Mod_1 : (forall x:int. (comp_mod(x,1) = 0))

axiom Div_inf :
  (forall x:int. forall y:int. (((0 <= x) and (x <  y)) ->
  (comp_div(x,y) = 0)))

axiom Mod_inf :
  (forall x:int. forall y:int. (((0 <= x) and (x <  y)) ->
  (comp_mod(x,y) = x)))

axiom Div_mult :
  (forall x:int. forall y:int. forall z:int [comp_div(((x * y) + z),x)].
  (((0 <  x) and ((0 <= y) and (0 <= z))) ->
  (comp_div(((x * y) + z),x) = (y + comp_div(z,x)))))

axiom Mod_mult :
  (forall x:int. forall y:int. forall z:int [comp_mod(((x * y) + z),x)].
  (((0 <  x) and ((0 <= y) and (0 <= z))) ->
  (comp_mod(((x * y) + z),x) = comp_mod(z,x))))

(**************************************************************************)
(*                                                                        *)
(*  The Why3 Verification Platform   /   The Why3 Development Team        *)
(*  Copyright 2010-2013   --   INRIA - CNRS - Paris-Sud University        *)
(*                                                                        *)
(*  This software is distributed under the terms of the GNU Lesser        *)
(*  General Public License version 2.1, with the special exception        *)
(*  on linking described in file LICENSE.                                 *)
(*                                                                        *)
(*  File modified by CEA (Commissariat à l'énergie atomique et aux        *)
(*                        énergies alternatives).                         *)
(*                                                                        *)
(**************************************************************************)

(* this is the prelude for Alt-Ergo, version >= 0.95.2 *)
(* this is a prelude for Alt-Ergo real arithmetic *)
(** The theory BuiltIn_ must be appended to this file*)
(** The theory Bool_ must be appended to this file*)
axiom add_div :
  (forall x:real. forall y:real. forall z:real. ((not (z = 0.0)) ->
  (((x + y) / z) = ((x / z) + (y / z)))))

axiom sub_div :
  (forall x:real. forall y:real. forall z:real. ((not (z = 0.0)) ->
  (((x - y) / z) = ((x / z) - (y / z)))))

axiom neg_div :
  (forall x:real. forall y:real. ((not (y = 0.0)) ->
  (((-x) / y) = (-(x / y)))))

axiom assoc_mul_div :
  (forall x:real. forall y:real. forall z:real. ((not (z = 0.0)) ->
  (((x * y) / z) = (x * (y / z)))))

axiom assoc_div_mul :
  (forall x:real. forall y:real. forall z:real. (((not (y = 0.0)) and
  (not (z = 0.0))) -> (((x / y) / z) = (x / (y * z)))))

axiom assoc_div_div :
  (forall x:real. forall y:real. forall z:real. (((not (y = 0.0)) and
  (not (z = 0.0))) -> ((x / (y / z)) = ((x * z) / y))))

(**************************************************************************)
(*                                                                        *)
(*  The Why3 Verification Platform   /   The Why3 Development Team        *)
(*  Copyright 2010-2013   --   INRIA - CNRS - Paris-Sud University        *)
(*                                                                        *)
(*  This software is distributed under the terms of the GNU Lesser        *)
(*  General Public License version 2.1, with the special exception        *)
(*  on linking described in file LICENSE.                                 *)
(*                                                                        *)
(*  File modified by CEA (Commissariat à l'énergie atomique et aux        *)
(*                        énergies alternatives).                         *)
(*                                                                        *)
(**************************************************************************)

(* this is the prelude for Alt-Ergo, version >= 0.95.2 *)
(** The theory BuiltIn_ must be appended to this file*)
(** The theory Bool_ must be appended to this file*)
(** The theory real_Real_ must be appended to this file*)
(**************************************************************************)
(*                                                                        *)
(*  The Why3 Verification Platform   /   The Why3 Development Team        *)
(*  Copyright 2010-2013   --   INRIA - CNRS - Paris-Sud University        *)
(*                                                                        *)
(*  This software is distributed under the terms of the GNU Lesser        *)
(*  General Public License version 2.1, with the special exception        *)
(*  on linking described in file LICENSE.                                 *)
(*                                                                        *)
(*  File modified by CEA (Commissariat à l'énergie atomique et aux        *)
(*                        énergies alternatives).                         *)
(*                                                                        *)
(**************************************************************************)

(* this is the prelude for Alt-Ergo, version >= 0.95.2 *)
(** The theory BuiltIn_ must be appended to this file*)
(** The theory Bool_ must be appended to this file*)
(** The theory int_Int_ must be appended to this file*)
(** The theory real_Real_ must be appended to this file*)
logic from_int : int -> real

axiom Zero : (from_int(0) = 0.0)

axiom One : (from_int(1) = 1.0)

axiom Add :
  (forall x:int. forall y:int.
  (from_int((x + y)) = (from_int(x) + from_int(y))))

axiom Sub :
  (forall x:int. forall y:int.
  (from_int((x - y)) = (from_int(x) - from_int(y))))

axiom Mul :
  (forall x:int. forall y:int.
  (from_int((x * y)) = (from_int(x) * from_int(y))))

axiom Neg : (forall x:int. (from_int((-x)) = (-from_int(x))))

axiom Monotonic :
  (forall x:int. forall y:int. ((x <= y) -> (from_int(x) <= from_int(y))))

(**************************************************************************)
(*                                                                        *)
(*  This file is part of WP plug-in of Frama-C.                           *)
(*                                                                        *)
(*  Copyright (C) 2007-2018                                               *)
(*    CEA (Commissariat a l'energie atomique et aux energies              *)
(*         alternatives)                                                  *)
(*                                                                        *)
(*  you can redistribute it and/or modify it under the terms of the GNU   *)
(*  Lesser General Public License as published by the Free Software       *)
(*  Foundation, version 2.1.                                              *)
(*                                                                        *)
(*  It is distributed in the hope that it will be useful,                 *)
(*  but WITHOUT ANY WARRANTY; without even the implied warranty of        *)
(*  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         *)
(*  GNU Lesser General Public License for more details.                   *)
(*                                                                        *)
(*  See the GNU Lesser General Public License version 2.1                 *)
(*  for more details (enclosed in the file licenses/LGPLv2.1).            *)
(*                                                                        *)
(**************************************************************************)

(* this is the prelude for Alt-Ergo, version >= 0.95.2 *)
(** The theory BuiltIn_ must be appended to this file*)
(** The theory Bool_ must be appended to this file*)
(** The theory bool_Bool_ must be appended to this file*)
(** The theory int_Int_ must be appended to this file*)
(** The theory int_Abs_ must be appended to this file*)
(** The theory int_ComputerDivision_ must be appended to this file*)
(** The theory real_Real_ must be appended to this file*)
(** The theory real_RealInfix_ must be appended to this file*)
(** The theory real_FromInt_ must be appended to this file*)
logic match_bool : bool, 'a, 'a -> 'a

axiom match_bool1 :
  (forall p:bool. forall x:'a. forall y:'a [match_bool(p, x, y)].
  (((p = true) and (match_bool(p, x, y) = x)) or ((p = false) and
  (match_bool(p, x, y) = y))))

logic eqb : 'a, 'a -> bool

axiom eqb1 : (forall x:'a. forall y:'a. ((eqb(x, y) = true) -> (x = y)))

axiom eqb2 : (forall x:'a. forall y:'a. ((x = y) -> (eqb(x, y) = true)))

logic neqb : 'a, 'a -> bool

axiom neqb1 :
  (forall x:'a. forall y:'a. ((neqb(x, y) = true) -> (not (x = y))))

axiom neqb2 :
  (forall x:'a. forall y:'a. ((not (x = y)) -> (neqb(x, y) = true)))

logic zlt : int, int -> bool

logic zleq : int, int -> bool

axiom zlt1 : (forall x:int. forall y:int. ((zlt(x, y) = true) -> (x <  y)))

axiom zlt2 : (forall x:int. forall y:int. ((x <  y) -> (zlt(x, y) = true)))

axiom zleq1 : (forall x:int. forall y:int. ((zleq(x, y) = true) -> (x <= y)))

axiom zleq2 : (forall x:int. forall y:int. ((x <= y) -> (zleq(x, y) = true)))

logic rlt : real, real -> bool

logic rleq : real, real -> bool

axiom rlt1 : (forall x:real. forall y:real. ((rlt(x, y) = true) -> (x <  y)))

axiom rlt2 : (forall x:real. forall y:real. ((x <  y) -> (rlt(x, y) = true)))

axiom rleq1 :
  (forall x:real. forall y:real. ((rleq(x, y) = true) -> (x <= y)))

axiom rleq2 :
  (forall x:real. forall y:real. ((x <= y) -> (rleq(x, y) = true)))

function real_of_int(x: int) : real = from_int(x)

axiom c_euclidian :
  (forall n:int. forall d:int [comp_div(n,d), comp_mod(n,d)].
  ((not (d = 0)) -> (n = ((comp_div(n,d) * d) + comp_mod(n,d)))))

axiom cdiv_cases :
  (forall n:int. forall d:int [comp_div(n,d)]. ((0 <= n) -> ((0 <  d) ->
  (comp_div(n,d) = (n / d)))))

axiom cdiv_cases1 :
  (forall n:int. forall d:int [comp_div(n,d)]. ((n <= 0) -> ((0 <  d) ->
  (comp_div(n,d) = (-((-n) / d))))))

axiom cdiv_cases2 :
  (forall n:int. forall d:int [comp_div(n,d)]. ((0 <= n) -> ((d <  0) ->
  (comp_div(n,d) = (-(n / (-d)))))))

axiom cdiv_cases3 :
  (forall n:int. forall d:int [comp_div(n,d)]. ((n <= 0) -> ((d <  0) ->
  (comp_div(n,d) = ((-n) / (-d))))))

axiom cmod_cases :
  (forall n:int. forall d:int [comp_mod(n,d)]. ((0 <= n) -> ((0 <  d) ->
  (comp_mod(n,d) = (n % d)))))

axiom cmod_cases1 :
  (forall n:int. forall d:int [comp_mod(n,d)]. ((n <= 0) -> ((0 <  d) ->
  (comp_mod(n,d) = (-((-n) % d))))))

axiom cmod_cases2 :
  (forall n:int. forall d:int [comp_mod(n,d)]. ((0 <= n) -> ((d <  0) ->
  (comp_mod(n,d) = (n % (-d))))))

axiom cmod_cases3 :
  (forall n:int. forall d:int [comp_mod(n,d)]. ((n <= 0) -> ((d <  0) ->
  (comp_mod(n,d) = (-((-n) % (-d)))))))

axiom cmod_remainder :
  (forall n:int. forall d:int [comp_mod(n,d)]. ((0 <= n) -> ((0 <  d) ->
  (0 <= comp_mod(n,d)))))

axiom cmod_remainder1 :
  (forall n:int. forall d:int [comp_mod(n,d)]. ((0 <= n) -> ((0 <  d) ->
  (comp_mod(n,d) <  d))))

axiom cmod_remainder2 :
  (forall n:int. forall d:int [comp_mod(n,d)]. ((n <= 0) -> ((0 <  d) ->
  ((-d) <  comp_mod(n,d)))))

axiom cmod_remainder3 :
  (forall n:int. forall d:int [comp_mod(n,d)]. ((n <= 0) -> ((0 <  d) ->
  (comp_mod(n,d) <= 0))))

axiom cmod_remainder4 :
  (forall n:int. forall d:int [comp_mod(n,d)]. ((0 <= n) -> ((d <  0) ->
  (0 <= comp_mod(n,d)))))

axiom cmod_remainder5 :
  (forall n:int. forall d:int [comp_mod(n,d)]. ((0 <= n) -> ((d <  0) ->
  (comp_mod(n,d) <  (-d)))))

axiom cmod_remainder6 :
  (forall n:int. forall d:int [comp_mod(n,d)]. ((n <= 0) -> ((d <  0) ->
  (d <  comp_mod(n,d)))))

axiom cmod_remainder7 :
  (forall n:int. forall d:int [comp_mod(n,d)]. ((n <= 0) -> ((d <  0) ->
  (comp_mod(n,d) <= 0))))

axiom cdiv_neutral : (forall a:int [comp_div(a,1)]. (comp_div(a,1) = a))

axiom cdiv_inv :
  (forall a:int [comp_div(a,a)]. ((not (a = 0)) -> (comp_div(a,a) = 1)))

(**************************************************************************)
(*                                                                        *)
(*  This file is part of WP plug-in of Frama-C.                           *)
(*                                                                        *)
(*  Copyright (C) 2007-2018                                               *)
(*    CEA (Commissariat a l'energie atomique et aux energies              *)
(*         alternatives)                                                  *)
(*                                                                        *)
(*  you can redistribute it and/or modify it under the terms of the GNU   *)
(*  Lesser General Public License as published by the Free Software       *)
(*  Foundation, version 2.1.                                              *)
(*                                                                        *)
(*  It is distributed in the hope that it will be useful,                 *)
(*  but WITHOUT ANY WARRANTY; without even the implied warranty of        *)
(*  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         *)
(*  GNU Lesser General Public License for more details.                   *)
(*                                                                        *)
(*  See the GNU Lesser General Public License version 2.1                 *)
(*  for more details (enclosed in the file licenses/LGPLv2.1).            *)
(*                                                                        *)
(**************************************************************************)

(* this is the prelude for Alt-Ergo, version >= 0.95.2 *)
(** The theory BuiltIn_ must be appended to this file*)
(** The theory Bool_ must be appended to this file*)
(** The theory bool_Bool_ must be appended to this file*)
(** The theory int_Int_ must be appended to this file*)
(** The theory map_Map_ must be appended to this file*)
type addr = { base : int; offset : int
}

logic addr_le : addr, addr -> prop

logic addr_lt : addr, addr -> prop

logic addr_le_bool : addr, addr -> bool

logic addr_lt_bool : addr, addr -> bool

axiom addr_le_def :
  (forall p:addr. forall q:addr [addr_le(p, q)]. (((p).base = (q).base) ->
  (addr_le(p, q) -> ((p).offset <= (q).offset))))

axiom addr_le_def1 :
  (forall p:addr. forall q:addr [addr_le(p, q)]. (((p).base = (q).base) ->
  (((p).offset <= (q).offset) -> addr_le(p, q))))

axiom addr_lt_def :
  (forall p:addr. forall q:addr [addr_lt(p, q)]. (((p).base = (q).base) ->
  (addr_lt(p, q) -> ((p).offset <  (q).offset))))

axiom addr_lt_def1 :
  (forall p:addr. forall q:addr [addr_lt(p, q)]. (((p).base = (q).base) ->
  (((p).offset <  (q).offset) -> addr_lt(p, q))))

axiom addr_le_bool_def :
  (forall p:addr. forall q:addr [addr_le_bool(p, q)]. (addr_le(p, q) ->
  (addr_le_bool(p, q) = true)))

axiom addr_le_bool_def1 :
  (forall p:addr. forall q:addr [addr_le_bool(p, q)]. ((addr_le_bool(p,
  q) = true) -> addr_le(p, q)))

axiom addr_lt_bool_def :
  (forall p:addr. forall q:addr [addr_lt_bool(p, q)]. (addr_lt(p, q) ->
  (addr_lt_bool(p, q) = true)))

axiom addr_lt_bool_def1 :
  (forall p:addr. forall q:addr [addr_lt_bool(p, q)]. ((addr_lt_bool(p,
  q) = true) -> addr_lt(p, q)))

function null() : addr = { base = 0; offset = 0 }

function global(b: int) : addr = { base = b; offset = 0 }

function shift(p: addr, k: int) : addr = { base = (p).base; offset =
  ((p).offset + k) }

predicate included(p: addr, a: int, q: addr, b: int) = ((0 <  a) ->
  ((0 <= b) and (((p).base = (q).base) and (((q).offset <= (p).offset) and
  (((p).offset + a) <= ((q).offset + b))))))

predicate separated(p: addr, a: int, q: addr, b: int) = ((a <= 0) or
  ((b <= 0) or ((not ((p).base = (q).base)) or
  ((((q).offset + b) <= (p).offset) or (((p).offset + a) <= (q).offset)))))

predicate eqmem(m1: (addr,'a) farray, m2: (addr,'a) farray, p: addr,
  a1: int) =
  (forall q:addr [(m1[p])| (m2[q])]. (included(q, 1, p, a1) ->
  ((m1[q]) = (m2[q]))))

logic havoc : (addr,'a) farray, (addr,'a) farray, addr,
  int -> (addr,'a) farray

predicate valid_rw(m: (int,int) farray, p: addr, n: int) = ((0 <  n) ->
  ((0 <  (p).base) and ((0 <= (p).offset) and
  (((p).offset + n) <= (m[(p).base])))))

predicate valid_rd(m: (int,int) farray, p: addr, n: int) = ((0 <  n) ->
  ((not (0 = (p).base)) and ((0 <= (p).offset) and
  (((p).offset + n) <= (m[(p).base])))))

predicate invalid(m: (int,int) farray, p: addr, n: int) = ((0 <  n) ->
  (((m[(p).base]) <= (p).offset) or (((p).offset + n) <= 0)))

axiom valid_rw_rd :
  (forall m:(int,int) farray.
  (forall p:addr. (forall n:int. (valid_rw(m, p, n) -> valid_rd(m, p, n)))))

axiom valid_string :
  (forall m:(int,int) farray.
  (forall p:addr. (((p).base <  0) -> (((0 <= (p).offset) and
  ((p).offset <  (m[(p).base]))) -> valid_rd(m, p, 1)))))

axiom valid_string1 :
  (forall m:(int,int) farray.
  (forall p:addr. (((p).base <  0) -> (((0 <= (p).offset) and
  ((p).offset <  (m[(p).base]))) -> (not valid_rw(m, p, 1))))))

axiom separated_1 :
  (forall p:addr. forall q:addr.
  (forall a:int. forall b:int. forall i:int. forall j:int [separated(p, a, q,
  b), { base = (p).base; offset = i }, { base = (q).base; offset = j }].
  (separated(p, a, q, b) -> ((((p).offset <= i) and
  (i <  ((p).offset + a))) -> ((((q).offset <= j) and
  (j <  ((q).offset + b))) -> (not ({ base = (p).base; offset = i } = {
  base = (q).base; offset = j })))))))

logic region : int -> int

logic linked : (int,int) farray -> prop

logic sconst : (addr,int) farray -> prop

predicate framed(m: (addr,addr) farray) =
  (forall p:addr [(m[p])]. (region(((m[p])).base) <= 0))

axiom separated_included :
  (forall p:addr. forall q:addr.
  (forall a:int. forall b:int [separated(p, a, q, b), included(p, a, q, b)].
  ((0 <  a) -> ((0 <  b) -> (separated(p, a, q, b) -> (not included(p, a, q,
  b)))))))

axiom included_trans :
  (forall p:addr. forall q:addr. forall r:addr.
  (forall a:int. forall b:int. forall c:int [included(p, a, q, b),
  included(q, b, r, c)]. (included(p, a, q, b) -> (included(q, b, r, c) ->
  included(p, a, r, c)))))

axiom separated_trans :
  (forall p:addr. forall q:addr. forall r:addr.
  (forall a:int. forall b:int. forall c:int [included(p, a, q, b),
  separated(q, b, r, c)]. (included(p, a, q, b) -> (separated(q, b, r, c) ->
  separated(p, a, r, c)))))

axiom separated_sym :
  (forall p:addr. forall q:addr.
  (forall a:int. forall b:int [separated(p, a, q, b)]. (separated(p, a, q,
  b) -> separated(q, b, p, a))))

axiom separated_sym1 :
  (forall p:addr. forall q:addr.
  (forall a:int. forall b:int [separated(p, a, q, b)]. (separated(q, b, p,
  a) -> separated(p, a, q, b))))

axiom eqmem_included :
  (forall m1:(addr,'a) farray. forall m2:(addr,'a) farray.
  (forall p:addr. forall q:addr.
  (forall a1:int. forall b:int [eqmem(m1, m2, p, a1), eqmem(m1, m2, q, b)].
  (included(p, a1, q, b) -> (eqmem(m1, m2, q, b) -> eqmem(m1, m2, p, a1))))))

axiom eqmem_sym :
  (forall m1:(addr,'a) farray. forall m2:(addr,'a) farray.
  (forall p:addr.
  (forall a1:int. (eqmem(m1, m2, p, a1) -> eqmem(m2, m1, p, a1)))))

axiom havoc_access :
  (forall m0:(addr,'a) farray. forall m1:(addr,'a) farray.
  (forall q:addr. forall p:addr.
  (forall a1:int. (separated(q, 1, p, a1) -> ((havoc(m0, m1, p,
  a1)[q]) = (m1[q]))))))

axiom havoc_access1 :
  (forall m0:(addr,'a) farray. forall m1:(addr,'a) farray.
  (forall q:addr. forall p:addr.
  (forall a1:int. ((not separated(q, 1, p, a1)) -> ((havoc(m0, m1, p,
  a1)[q]) = (m0[q]))))))

logic int_of_addr : addr -> int

logic addr_of_int : int -> addr

logic base_offset : int -> int

logic base_index : int -> int

axiom int_of_addr_bijection :
  (forall a:int. (int_of_addr(addr_of_int(a)) = a))

axiom addr_of_int_bijection :
  (forall p:addr. (addr_of_int(int_of_addr(p)) = p))

axiom addr_of_null : (int_of_addr(null) = 0)

axiom base_offset_zero : (base_offset(0) = 0)

axiom base_offset_inj : (forall i:int. (base_index(base_offset(i)) = i))

axiom base_offset_monotonic :
  (forall i:int. forall j:int. ((i <  j) ->
  (base_offset(i) <  base_offset(j))))

(* ---------------------------------------------------------- *)
(* --- Memory Compound Updates                            --- *)
(* ---------------------------------------------------------- *)

function shift_sint8(p:addr, k:int) : addr = shift(p, k)

function shift_sint32(p:addr, k:int) : addr = shift(p, k)

function shiftfield_F8__LogEntry_hash(p:addr) : addr = shift(p, 0)

function shiftfield_F8__LogEntry_msg(p:addr) : addr = shift(p, 1)

function shift___fc_FILE(p:addr, k:int) : addr = shift(p, 2 * k)

(* ---------------------------------------------------------- *)
(* --- Global Definitions (continued #14)                 --- *)
(* ---------------------------------------------------------- *)

logic L_abstract_region : addr

predicate P_valid_le
    (Malloc_0:int farray,
    le_0:addr) =
    valid_rd(Malloc_0, le_0, 257) and
    valid_rd(Malloc_0, shift_sint8(shiftfield_F8__LogEntry_msg(le_0), 0),
      256)

predicate P_valid_input
    (Malloc_0:int farray,
    le1_0:addr,
    le2_0:addr) =
    P_valid_le(Malloc_0, le1_0) and P_valid_le(Malloc_0, le2_0) and
    separated(shift_sint8(shiftfield_F8__LogEntry_msg(le1_0), 0), 256,
      shift_sint8(shiftfield_F8__LogEntry_msg(le2_0), 0), 256)

predicate P_hash_equal
    (Mint_0:(addr,int) farray,
    le1_0:addr,
    le2_0:addr) =
    Mint_0[shiftfield_F8__LogEntry_hash(le2_0)]
      = Mint_0[shiftfield_F8__LogEntry_hash(le1_0)]

(* ---------------------------------------------------------- *)
(* --- Axiomatic 'State'                                  --- *)
(* ---------------------------------------------------------- *)

axiom Q_internal_state:
  forall filename_0 : addr.
  L_abstract_region = filename_0

(* ---------------------------------------------------------- *)
(* --- Axiomatic 'MemCmp'                                 --- *)
(* ---------------------------------------------------------- *)

logic L_memcmp : (addr,int) farray,(addr,int) farray,addr,addr,int -> int

axiom Q_memcmp_zero:
  forall s1_0,s2_0 : addr.
  forall Mchar_0,Mchar_1 : (addr,int) farray.
  forall n : int.
  (forall i : int. (0 <= i) -> (i < n) ->
   (Mchar_1[shift_sint8(s1_0, i)] = Mchar_0[shift_sint8(s2_0, i)])) <->
    (L_memcmp(Mchar_0, Mchar_1, s1_0, s2_0, n) = 0)

(* ---------------------------------------------------------- *)
(* --- Axiomatic 'StrLen'                                 --- *)
(* ---------------------------------------------------------- *)

logic L_strlen : (addr,int) farray,addr -> int

axiom Q_strlen_pos_or_null:
  forall s : addr.
  forall Mchar_0 : (addr,int) farray.
  forall i : int.
  (Mchar_0[shift_sint8(s, i)] = 0) -> (0 <= i) ->
    (forall i_1 : int. (0 <= i_1) -> (i_1 < i) ->
     (Mchar_0[shift_sint8(s, i_1)] <> 0)) -> (L_strlen(Mchar_0, s) = i)

axiom Q_strlen_neg:
  forall s : addr.
  forall Mchar_0 : (addr,int) farray.
  (forall i : int. (0 <= i) -> (Mchar_0[shift_sint8(s, i)] <> 0)) ->
    (L_strlen(Mchar_0, s) < 0)

axiom Q_strlen_before_null:
  forall s : addr.
  forall Mchar_0 : (addr,int) farray.
  forall i : int.
  (0 <= i) -> (i < L_strlen(Mchar_0, s)) -> (Mchar_0[shift_sint8(s, i)] <> 0)

axiom Q_strlen_at_null:
  forall s : addr.
  forall Mchar_0 : (addr,int) farray.
  (0 <= L_strlen(Mchar_0, s)) ->
    (Mchar_0[shift_sint8(s, L_strlen(Mchar_0, s))] = 0)

axiom Q_strlen_not_zero:
  forall s : addr.
  forall Mchar_0 : (addr,int) farray.
  forall i : int.
  (Mchar_0[shift_sint8(s, i)] <> 0) -> (0 <= i) ->
    (i <= L_strlen(Mchar_0, s)) -> (i < L_strlen(Mchar_0, s))

axiom Q_strlen_zero:
  forall s : addr.
  forall Mchar_0 : (addr,int) farray.
  forall i : int.
  (Mchar_0[shift_sint8(s, i)] = 0) -> (0 <= i) ->
    (i <= L_strlen(Mchar_0, s)) -> (L_strlen(Mchar_0, s) = i)

axiom Q_strlen_sup:
  forall s : addr.
  forall Mchar_0 : (addr,int) farray.
  forall i : int.
  (Mchar_0[shift_sint8(s, i)] = 0) -> (0 <= i) ->
    ((L_strlen(Mchar_0, s) <= i) and (0 <= L_strlen(Mchar_0, s)))

axiom Q_strlen_shift:
  forall s : addr.
  forall Mchar_0 : (addr,int) farray.
  forall i : int.
  (0 <= i) -> (i <= L_strlen(Mchar_0, s)) ->
    ((i + L_strlen(Mchar_0, shift_sint8(s, i))) = L_strlen(Mchar_0, s))

axiom Q_strlen_create:
  forall s : addr.
  forall Mchar_0 : (addr,int) farray.
  forall i : int.
  (Mchar_0[shift_sint8(s, i)] = 0) -> (0 <= i) ->
    ((L_strlen(Mchar_0, s) <= i) and (0 <= L_strlen(Mchar_0, s)))

axiom Q_strlen_create_shift:
  forall s : addr.
  forall Mchar_0 : (addr,int) farray.
  forall i,k : int.
  (Mchar_0[shift_sint8(s, i)] = 0) -> (k <= i) -> (0 <= k) ->
    ((0 <= L_strlen(Mchar_0, shift_sint8(s, k))) and
     ((k + L_strlen(Mchar_0, shift_sint8(s, k))) <= i))

axiom Q_memcmp_strlen_left:
  forall s1_0,s2_0 : addr.
  forall Mchar_0 : (addr,int) farray.
  forall n : int.
  (L_memcmp(Mchar_0, Mchar_0, s1_0, s2_0, n) = 0) ->
    (L_strlen(Mchar_0, s1_0) < n) ->
    (L_strlen(Mchar_0, s2_0) = L_strlen(Mchar_0, s1_0))

axiom Q_memcmp_strlen_right:
  forall s1_0,s2_0 : addr.
  forall Mchar_0 : (addr,int) farray.
  forall n : int.
  (L_memcmp(Mchar_0, Mchar_0, s1_0, s2_0, n) = 0) ->
    (L_strlen(Mchar_0, s2_0) < n) ->
    (L_strlen(Mchar_0, s2_0) = L_strlen(Mchar_0, s1_0))

axiom Q_memcmp_strlen_shift_left:
  forall s1_0,s2_0 : addr.
  forall Mchar_0 : (addr,int) farray.
  forall k,n : int.
  (L_memcmp(Mchar_0, Mchar_0, s1_0, shift_sint8(s2_0, k), n) = 0) ->
    (0 <= k) -> (L_strlen(Mchar_0, s1_0) < n) ->
    ((0 <= L_strlen(Mchar_0, s2_0)) and
     (L_strlen(Mchar_0, s2_0) <= (k + L_strlen(Mchar_0, s1_0))))

axiom Q_memcmp_strlen_shift_right:
  forall s1_0,s2_0 : addr.
  forall Mchar_0 : (addr,int) farray.
  forall k,n : int.
  (L_memcmp(Mchar_0, Mchar_0, shift_sint8(s1_0, k), s2_0, n) = 0) ->
    (0 <= k) -> (L_strlen(Mchar_0, s2_0) < n) ->
    ((0 <= L_strlen(Mchar_0, s1_0)) and
     (L_strlen(Mchar_0, s1_0) <= (k + L_strlen(Mchar_0, s2_0))))

(* ---------------------------------------------------------- *)
(* --- Global Definitions (continued #11)                 --- *)
(* ---------------------------------------------------------- *)

predicate P_valid_read_string
    (Malloc_0:int farray,
    Mchar_0:(addr,int) farray,
    s:addr) =
    let x = L_strlen(Mchar_0, s) : int in (0 <= x) and
    valid_rd(Malloc_0, shift_sint8(s, 0), 1 + x)

(* ---------------------------------------------------------- *)
(* --- String Literals                                    --- *)
(* ---------------------------------------------------------- *)

logic Str_1 : int

logic Lit_F1B0 : int farray

axiom Q_Str_1_base: Str_1 < 0

axiom Q_Str_1_region: region(Str_1) = (-61872)

axiom Q_Str_1_linked: forall t : int farray. linked(t) -> (t[Str_1] = 2)

axiom Q_Str_1_literal:
  forall mchar_0 : (addr,int) farray.
  forall i : int.
  sconst(mchar_0) -> (mchar_0[shift_sint8(global(Str_1), i)] = Lit_F1B0[i])

(* ---------------------------------------------------------- *)
(* --- Instance of 'Pre-condition 'valid_mode' in 'fopen'' in 'write_entry' at initialization of '_f' (file logging.c, line 16)
 --- *)
(* ---------------------------------------------------------- *)

goal write_entry_call_fopen_pre_valid_mode:
  forall t : int farray.
  forall t_1 : (addr,int) farray.
  forall a_2,a_1,a : addr.
  (region(a.base) <= 0) ->
  (region(a_1.base) <= 0) ->
  (region(a_2.base) <= 0) ->
  linked(t) ->
  sconst(t_1) ->
  P_valid_le(t, a) ->
  valid_rw(t, a_2, 1) ->
  P_valid_read_string(t, t_1, a_2) ->
  P_valid_read_string(t, t_1, shift_sint8(global(Str_1), 0))

